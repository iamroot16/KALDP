# Chapter 5. Flow of control through the Kernel

1단계에서 우리는 현재 일어나고 있는 일의 큰 그림을 모두 한 그림에서 보았다. 이제 그림을 좀 더 멀리서 보자. 여기서는 1단계에서처럼 아주 상세하게 설명하지 않을 것이다. 우리는 0.01 커널이 부팅되는 동안과 후에 어떤 코드에 어떤 코드가 포함되어 있는지 그리고 어떤 코드 시퀀스가 뒤따르는지 간략히 언급할 것이다. 따라서 이 단계가 완료되면 "파일 이름" 수준에서 코드의 흐름을 숙지할 수 있을 것이다. 3단계에서는 "파일 이름"이 아닌 "기능 이름"에 의해 코드 경로를 추적할 수 있도록 각 파일의 코드를 설명할 것이다 :-\)

## 5.1.1. Normal Activities In a Running OS

OS는 부팅 후 무엇을 하는가? 주요 활동은 인터럽트/예외를 핸들링하는 것이며, 이를 통해 다른 모든 추상적 활동이 이루어진다. 예를 들어, OS가 가동되고 셸이 실행된 후, 사용자는 키보드가 인터럽트를 생성하는 것에 해당하는 명령을 입력할 수 있다. 쉘은 그러한 문자를 읽고, 명령으로 해석하며, 필요한 경우 시스템 호출을 하는데, 이 역시 OS에 의해 처리되는 인터럽트의 한 형태다. 또는 타이머 인터럽트를 처리하면서 새로운 태스크가 스케줄링될 수  있다.

## 5.1.2. linux/boot Directory

### 5.1.2.1. Boot Up - boot/boot.s

우리는 0.01을 빌드하여, 0x00을 시작 주소\(엔트리 포인트\)로 설정된 이미지를 가지게 되었다. 그러나 누가 이 코드를 커널 이미지를 0x00에 올려주는가? 바로 이 파일에서 그렇게 만들어준다. 386 프로세서는 전원이 켜지면, 고정된 시작 주소에서 실행된다\(0xFFFFFFF0\) 그런다음, ROM의 시작주소로 JMP하게 된다. boot ROM 코드는 각종 디바이스에\(floppy, hard disk\) 부팅 가능한 이미지가 있는지 확인한다. 우리의 경우는 플로피 디스크를 하고, 첫 섹터에 시그니처 값\(0xAA 0x55\)이 있으면, 해당 섹터를 고정된 위치\(0x7c00\)에 로드하고 해당 위치로 JMP한다. 이렇게 로드된 부분을 부트 로더라 부른다.  부트 로더는 0.01 소스에 일부이며, 입맛대로 수정할 수 있다. 부트 로더는 플로피 디스크에서 커널 이미지를 메모리에 로드해야 한다. 커널 이미지를 로드할때 0x00로 복사를 하며 복사가 완료된 후, 그 주소로 JMP한다. 또한 JMP하기 전에 real 모드에서 protected 모드로 전환하는 일도 수행한다. 

### 5.1.2.2. The “head” Of The Kernel - boot/head.s

커널 코드는 head.s로 시작하게 된다\(이게 바로 head.s라 불리는 이유다\). 이전 섹션에서 얘기했듯이 head.s로 진입히기 전에 더미 IDT, GDT, LDT를 세팅하고 protected모드로 전환 된다. 따라서 우리는 이런 더미 GDT, LDT, IDT를 제대로 세팅하는 것이다. 또 다른 과제는 메인 커널 코드를 실행하기 전에 페이징을 활성화 해야 한다. 이런 모든 과정이 수행되어야 인터럽트를 활성화 할 수 있고, 메인 커널 코드를 실행할 수 있다. 

## 5.1.3. linux/init Directory

### 5.1.3.1. The “main” Kernel - init/main.c

main.c 파일은 이름대로 main 함수를 포함하고 있다. head.s에서 main\(\)함수로 JMP하게된다. main 함수는 커널이 실제로 동작하기 전에 필요로 하는 초기화 과정을 수행한다\(예를 들어 콘솔, 하드 디스크, 파일 시스템\). 이러한 것들이 준비가 되서야 멀티 태스킹을 수행할 수 있다. 이제 모든 준비가 되었다면, 메인 함수는 fork를 통해 새로운 프로세스\(init  프로세스\)를 생성한다. 이 모든 과정을 수행하면,  0.01은 완전한 기능을 수행할 수 있다. 사용자 프로그램을 실행하며, 태스크를 스케줄링하고,  시스템 콜을 서비스할 것이다. 

## 5.1.4. linux/kernel Directory

### 5.1.4.1. Software int 0x80 - kernel/system\_call.s

해당 파일은 프로세스가 시스템 콜을 호출하거나, 예외를 발생했을때 처리되는 코드를 다루고 있다. 또한 시스템 콜을 호출했을 때 어떤 서비스를 실행해야 하는지를 구현한다. 또한 프로세스간 시그널 처리에 관련된 코드와, fork, exec, 타이머 인터럽트, 하드 디스크 인터럽트 핸들러도 구현한다.

### 5.1.4.2. System Calls - kernel/sys.c

해당 파일은 몇몇 시스템 콜을 구현한다. 

### 5.1.4.3. Exceptions - kernel/asm.s, kernel/traps.c

asm.s는 특정 예외 핸들러에 관련된 내용을,  traps.c는 IDT에 인터럽트 핸들러를 세팅한다. 

### 5.1.4.4. Console Functions - kernel/console.c, kernel/tty\_io.c

콘솔에 관련된 내용을 다룬다.

### 5.1.4.5. Miscellaneous Files - kenel/panic.c, kernel/mktime.c, kernel/vsprintf.c, kernel/printk.c

해당 파일은 커널 코어에서 굉장히 중요한 역할을 한다. printk 함수가 없다면 우리는 어떤 메시지도 출력할 수 없다.

### 5.1.4.6. Device Handling Code - kernel/hd.c, kernel/keyboard.s, kernel/rs\_io.s

이름과 같이 해당 파일들은 디바이스 관련된 인터럽트들을 다루고 있다. 디바이스를 다루기 위한 버퍼/큐들을 다룬다.

### 5.1.4.7. Important System Calls - fork\(\) & exit\(\) - kernel/fork.c, kernel/exit.c

fork 시스템 콜의 중요성은 계속해서 강조해도 부족하다. OS 코드를 처음 보는 사람에게는 fork의 구현은 정말 아름다울 것이다. exit 시스템 콜또한 중요하다. 그러나 그 구현은 fork의 아름다움보다는 덜하다.

### 5.1.4.8. The “heart” of the Kernel - scheduler - os/sched.c

우리는 앞서 타이머 인터럽트가 다중 시분할 OS의 심장이라고 언급했었다. 이 부분을 다루는 코드는 kernel/sched.c에서 다뤄진다. 타이머 인터럽트는 각각의 태스크가 실행된 시간을 알 수 있도록 한다. 만약 현재 태스크가 퀀텀 타임\(태스크에게 할당된 시간\)을 초과한다면, 다른 태스크를 실행하도록 스케줄링한다. 스케줄러는 태스크가 IO를 발생할 때에도 호출된다. IO가 완료되면 대기하던 태스크를 깨운다. kernel/sched.c는 이 외에도 여러 시스템 콜을 구현한다.

## 5.1.5. linux/mm Directory

### 5.1.5.1. Page Fault Handler - mm/page.s

앞서 언급했듯이, 페이지 폴트 핸들러는 두 가지 이유로 호출된다. 하나는 읽기 전용 페이지에 쓰려고 하거나, 다른 하나는 물리 페이지 프레임이 존재하지 않을 때이다. 해당 파일은 페이지 폴트가 발생했을 때 실행된다. 

### 5.1.5.2. C code for Page Not Present and Page Not Writable - mm/memory.c

해당 파일은 읽기 전용 페이지에 쓰려고 할 때 실행되는 코드를 담고 있다.

## 5.1.6. linux/fs Directory

### 5.1.6.1. fs/super.c

이 파일은 하드 디스크 위의 파일 시스템의 시작점이다. 슈퍼 블록을 읽고, 파일 시스템 구성 사항을 식별한다. 또한 루트 아이노드와 같은 커널 변수를 초기화 한다.

### 5.1.6.2. fs/buffer.c

해당 파일은 raw read/write 메커니즘 위의 레이어를 다룬다. read write은 최적화를 위해 버퍼에 캐시된다. 따라서 버퍼는 디스크 블록에 대응하고, free될 때 디스크에 write back된다. 

### 5.1.6.3. fs/bitmap.c, fs/inode.c, fs/namei.c, fs/truncate.c

커널은 루트 파일 시스템을 마운트하고, 파일 시스템의 시작점을 위해 루트 아이노드를 생성한다. 이제 파일 시스템에 대한 접근\(파일 생성/삭제\)은 아이노드를 통해서 진행된다. 

### 5.1.6.4. fs/block\_dev.c, fs/file\_dev.c, fs/char\_dev.c

0.01에는 3가지 종류의 디바이스가 지원된다. 블록 드바이스\(/dev/hda\) 파일, 파일 디바이스\(root/test.c\), 문자 디바이스\(dev/tty0\). 해당 디바이스에 대한 read와 write는 각각의 파일에서 구현된다. file\_dev.c와 block\_dev.c는 디스크 의 저수준 read/write 함수를 사용한다. 

### 5.1.6.5. fs/file\_table.c

시스템에서 열려 있는 파일을 저장하는 배열이다.

### 5.1.6.6. fs/open.c, fs/read\_write.c

무슨 타입의 파일이든 우리는 open, read, write 시스템 콜을 사용할 수 있다.해당 파일을 통해 커널에서 가장 높은 수준의 추상화 레이어를 제공한다.  

### 5.1.6.7. fs/fcntl.c, fs/ioctl.c, fs/tty\_ioctl.c, fs/stat.c

open/read/write 시스템 콜에 영향을 줄 수 있는 시스템 콜을 구현하고 있다.

### 5.1.6.8. fs/pipe.c

pipe을 구현하고 있다.

### 5.1.6.9. fs/exec.c

커널에서 두 번째로 아름다운 시스템 콜 구현이다. 이 파일은 exec 시스템 콜을 구현한다. 구현은 fork 보다는 좀 더 복잡하다.\(fork는 태스크 정보를 복사만 하면되지만, exec은 디스크로부터 데이터를 읽어야 한다\)

## 5.1.7. linux/lib Directory

해당 코드는 커널의 일부분은 아니다. 대신 사용자 프로그램을 위해 함께 패키징 되는 라이브러리이다. 이 파일들은 사용자 레벨의 프로그램이 시스템 콜을 쉽게 호출할 수 있도록 한다. 

## 5.1.8. linux/include Directory

이름과 같이 C 파일과 함께 포함되어야 하는 파일들을 포함하고 있다. 하지만 string.h와 같은 파일은 어셈블리로 짜여진 코드도 포함하고 있다. 디렉토리는 서브 디렉토리를 가지고 있고, 각종 유틸리티 매크로를 가지고 있다. 





