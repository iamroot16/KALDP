---
description: >-
  https://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#8086_I/O_ports
---

# Appendix A. Serial Programming\(8250 UART\)

이 섹션의 주요 초점은 82050 UART에 집중될 것이지만, 여기서 우리가 함께 작업할 컴퓨터 칩은 정말 세 가지다.

* 8250 UART
* 8259 PIC\(프로그램식 인터럽트 컨트롤러\)
* 8086 CPU\(중앙 처리 장치\)

 이들은 단순히 칩 부품 번호 자체가 아니라 칩 제품군임을 명심하십시오. 컴퓨터 디자인은 몇 년 동안 꽤 많이 진화해왔고, 세 개의 칩이 결합되어 같은 반도체에 넣는 경우가 많다. 그래서 해당 글에서 8086이라고 말할 때, 나는 80286, 80386, 펜티엄, 그리고 인텔 이외의 제조업체가 만든 호환 칩을 포함한 후속 칩을 의미한다. 다른 아키텍쳐들의 시리얼 데이터 통신에 대해 미묘한 차이가 있지만, 여러 소프트웨어에서 작동해야 한다? 

현대의 운영체제는 우리가 여기서 다루게 될 세부사항의 대부분을 낮은 수준의 드라이버를 통해 처리하므로, 이것은 당신이 자신의 운영체제를 만들지 않는 한, 당신이 스스로 구현할 수 있는 어떤 것 보다는 이것이 어떻게 작동하는지 더 빨리 이해할 수 있어야 한다. 작은 임베디드 컴퓨터 장치를 설계하는 사람들에게, 이 수준에서 8250을 이해하는 것이 상당히 더 중요해졌다.

8086과 마찬가지로 8250도 16550 UART에서 부터 상당히 진화했다. 더 아래로 내려가서 나는 PC에서 많은 다른 UART 칩들과 각각의 칩에 영향을 미치는 몇가지 기이한 점이나 변화를 감지하는 방법에 대해 연구할 것이다. 차이점은 CPU 아키텍처의 변경만큼 중요하지 않으며, UART 칩을 업데이트하는 주된 이유는 현재 사용 중인 CPU보다 훨씬 빠른 CPU에서 작동하도록 하기 위함이었다. 8250 자체는 단순히 펜티엄 칩을 따라가지 못한다.

소프트웨어 측면에서 직렬 프로그래밍을 위한 기반을 구축하려는 시도라는 점을 기억하십시오. 이것이 하드웨어 설계에도 유용할 수 있지만 전체 시스템을 구현하기 위해 여기 설명에서 상당히 누락될 것이다.

### 8086 I/O ports

우리는 인텔 8086보다 훨씬 더 멀리, 원래의 인텔 CPU인 4004와 그 후계자인 8008로 돌아가야 한다. 8008에 대한 모든 컴퓨터 지침, 즉 op-code는 오늘날의 인텔 칩에서 여전히 작동하므로 30년 전에 작성된 포트 I/O 튜토리얼도 오늘날에도 유효하다. 새로운 CPU는 더 많은 데이터를 더 효율적으로 처리하기 위한 지침을 강화했지만, 원래의 지침은 여전히 남아 있다.

8008이 출시되자 인텔은 CPU가 외부 장치와 통신할 수 있는 방법을 고안하려고 했다. 그들은 칩이 외부 장치와의 통신 전용의 핀셋을 가지고 있다는 것을 의미하는 I/O 포트 아키텍처라는 방법을 선택했다. 8008년, 이것은 칩과의 통신 전용 핀이 총 16개라는 것을 의미했다. 정확한 세부사항은 칩 설계와 현재 논의하기에는 너무 상세한 다른 요인에 따라 다양했지만, 일반적인 이론은 상당히 간단하다.

핀 중 8개는 특정 장치의 신호를 나타내는 I/O 코드를 나타낸다. 이를 I/O 포트라고 한다. 이 코드는 2진수 코드일 뿐이므로 256개의 다른 장치를 CPU에 연결할 수 있는 가능성을 나타낸다. 그것보다 조금 더 복잡해지지만, 당신은 여전히 그것의 고객들을 위해 256개의 PO 박스를 가지고 있는 작은 도시 우체국 같은 소프트웨어에서 그것을 생각할 수 있다.

다음 핀 세트는 교환되는 실제 데이터를 나타낸다. 당신은 이것을 PO 박스에 넣거나 PO 박스에서 꺼내는 엽서로 생각할 수 있다.

외부 장치가 해야 할 일은 입출력 코드를 찾는 것뿐이다. 그리고 나서 찾으려는 "할당"과 일치하면 해당 포트에 대한 제어권을 갖게 된다. 핀은 데이터가 CPU로 전송되는지 또는 CPU에서 전송되는지 여부를 표시한다. 초기 PC 설정에 익숙한 사람들에게도, 두 개 이상의 기기가 동시에 동일한 I/O 포트에 액세스하려고 할 때 입출력 충돌이 발생하는 곳이다. 이것은 특히 새로운 장비를 추가할 때 그러한 초기 시스템에 대한 속쓰림의 원천이었다.

이는 기존의 RAM 작동 방식과 매우 유사하며, 일부 CPU 설계는 RAM에서 이 전체 프로세스를 그대로 모방하여 I/O 제어를 위한 메모리 블록을 예약한다. 이것은 대신 소프트웨어에 사용될 수 있는 잠재적 메모리의 일부를 씹는 것을 포함하여 몇 가지 문제를 가지고 있다. 결국 IBM PC와 이후 PC 시스템에서는 메모리 맵 I/O\(Memory Mapped I/O\)와 PMIO\(Port-Mapped I/O\)가 모두 광범위하게 사용되기 때문에 정말 복잡해진다. 그러나 직렬 통신을 위해서는 8250 칩이 작동하는 방식인 만큼 포트 I/O 방식을 고수할 것이다.

### Software I/O access

9번 포트로 데이터를 보내거나 받기 위한 어셈빌리는 다음과 같다.

```text
out 9, al ; sending data from register al out to port 9 
in al, 9 ; getting data from port 9 and putting it in register al
```

더 높은 수준의 언어로 프로그래밍할 때, 그것은 좀 더 간단해진다. 일반적인 C 언어 포트 I/O 라이브러리는 일반적으로 다음과 같이 작성된다.

```text
char test;

test = 255;
outp(9,test);
inp(9,&test);
```

**경고!!** 그리고 이것은 정말 경고다. 어떤 포트에 연결되어 있는지 제대로 알지 못한 채 임의로 컴퓨터의 I/O 포트에 액세스하면 컴퓨터가 정말 엉망이 될 수 있다. 최소한 운영체제를 망가뜨리고 컴퓨터가 작동하지 않게 할 것이다. 일부 I/O 포트에 쓰는 것은 컴퓨터의 내부 구성을 영구적으로 바꿀 수 있으며, 소프트웨어를 통해 발생한 손상을 복구하는 데 필요한 수리점으로 이동할 수 있다. 더 나쁜 것은, 어떤 경우에는 컴퓨터에 실제적인 손상을 입힐 수 있다. 이는 컴퓨터 내부의 일부 칩이 더 이상 작동하지 않을 것이고 컴퓨터가 다시 작동하기 위해서는 그 부품들을 교체해야 한다는 것을 의미한다. 손상된 칩은 컴퓨터 부분의 형편없는 공학을 나타내는 것이지만, 불행히도 그런 일이 일어나기 때문에 여러분은 그것을 알아야 한다.

I/O 포트를 사용하는 것을 두려워하지 말고, 쓰는 것을 확실히 하고, 특정 I/O 포트를 사용하려는 경우 각 I/O 포트에 대해 어떤 장비가 "매핑"되는지 확인하십시오. 우리는 시리얼 통신을 위한 I/O 포트를 어떻게 식별하는지에 대해 좀 더 세부적인 정보를 얻을 것이다. 마침내 우리는 약간의 소프트웨어를 쓰기 시작했으며, 앞으로 더 많은 소프트웨어를 만들 것이다.

### x86 포트 I/O 확장

8008 CPU와 8086 사이에는 몇 가지 차이점이 있다. 소프트웨어 개발에 영향을 미치는 가장 주목할 만한 점은 포트 I/O 주소 256개 대신 8086이 65536개의 서로 다른 I/O 포트에 접근할 수 있다는 점이다. 그러나 컴퓨터 구성은 IBM PC의 경우 16개 이하의 와이어를 사용할 수 있다. 예를 들어, 10개의 와이어만 사용되어 1024개의 서로 다른 포트만 만들었다. 무시되고 있는 포트 번호의 더 높은 비트는 동일한 포트에 대해 여러 포트 번호 별칭을 만들었다.

게다가, 8086은 단순히 하나의 문자를 안이나 밖으로 보내는 것 외에, 16비트를 한 번에 주고받을 수 있게 해줄 것이다. 16비트 워드 바이트는 연속 포트 번호를 사용하여 작은 엔디안어로 읽거나 쓴다. 386 칩은 32비트까지 동시에 주고받을 수 있게 해준다. 65536개 이상의 서로 다른 I/O 포트의 필요성이 심각한 문제가 된 적이 없으며, 장치에 더 큰 메모리가 필요한 경우 DMA\(Direct Memory Access\) 방법을 사용할 수 있다. 이 곳은 장치가 CPU를 거치지 않고 컴퓨터의 RAM을 직접 쓰고 읽는 곳이다. 우리는 여기서 그 주제를 다루지 않을 것이다.

또한 8086 CPU는 65536개의 서로 다른 I/O 포트를 처리할 수 있었지만 실제로는 그렇지 않았다. 인텔의 칩 설계자들은 가격이 저렴해졌고 단지 10비트에 대한 어드레스 라인만 가지고 있었는데, 이것은 소프트웨어 설계자들이 레거시 시스템과 함께 일해야 한다는 것을 의미한다. 이는 I/O 포트 주소 $1E8 및 $19E8\(및 기타...\)도 의미했다. 이것은 단지 예시일 뿐이다\)는 초기 PC의 동일한 I/O 포트로 해결된다. 펜티엄 CPU에는 이러한 제한이 없지만, 초기 하드웨어 중 일부를 위해 작성된 소프트웨어는 때때로 상위 비트가 무시되었기 때문에 "aliased"된 I/O 포트 주소에 쓰이기도 했다. 다른 과거의 문제들이 나타나지만, 다행히도 82050 칩과 시리얼 통신의 경우, 이러한 앨리어싱 상황을 "이점으로 삼는" 시리얼 드라이버를 가지고 있지 않는 한, 이것은 문제가 되지 않는다. 이 문제는 일반적으로 PC의 일반적인 2개 또는 4개 직렬 COM 포트 이상을 사용하는 경우에만 나타난다.

### x86 프로세서 인터럽트 

8086 CPU와 호환 칩은 인터럽트 라인으로 알려진 것을 가지고 있다. 이것은 말 그대로 CPU가 하고 있는 모든 것을 멈추고 일부 I/O 상황에 주의를 기울여야 할 때라는 것을 알리기 위해 전원이 켜질 수 있는 나머지 컴퓨터에 연결된 전선이다.

8086년 내에는 다음과 같은 두 가지 종류의 인터럽트가 있다. 하드웨어 인터럽트 및 소프트웨어 인터럽트. 각 종류마다 다른 흥미로운 기이한 점들이 있지만, 소프트웨어적 관점에서 보면 본질적으로 같은 것이다. 8086 CPU는 256개의 인터럽트를 허용하지만, 하드웨어 인터럽트를 수행하는 장비에 사용할 수 있는 번호는 상당히 제한되어 있다.

### 설명된 IRQ

 하드웨어 인터럽트는 IRQ 0부터 IRQ 15까지 번호가 매겨진다. IRQ는 인터럽트 리퀘스트를 의미한다. 총 15개의 서로 다른 하드웨어 인터럽트가 있다. 내가 셈이나 수학을 할 줄 모른다고 생각하기 전에, 우리는 여기서 약간의 역사 수업을 해야 한다. 우리가 8259 칩으로 넘어가면 끝마칠 것이다. 원래의 IBM-PC가 구축되었을 때, IRQ 0부터 IRQ 7까지라는 라벨이 붙은 IRQ는 8개뿐이었는데, 그 당시에는 PC에 올려질 거의 모든 것에 충분하다고 생각되었지만, 곧 그것이 추가되고 있는 모든 것에 충분하지 않다는 것이 명백해졌다. IBM-PC/AT가 만들어졌을 때\(80286 CPU를 탑재한 첫 번째 것과 오늘날 PC에서 흔히 볼 수 있는 여러 가지 향상 기능\) 8259 칩을 1개 사용하는 대신 이 같은 칩을 2개 사용하고, 인터럽트 수를 8개에서 15개로 확대하기 위해 서로 "체인"하기로 결정했다. 이 임무를 완수하기 위해서는 IRQ 한 개를 희생시켜야 했고, 그것은 IRQ 2였다.

여기서 요점은 CPU에 대해 어느 정도의 데이터가 준비되어 있다는 것을 기기가 CPU에 알리려면 현재 컴퓨터에서 실행되고 있는 모든 소프트웨어를 중지하고 대신 인터럽트 핸들러라고 하는 특별한 "작은" 프로그램을 실행하고 싶다는 신호를 보낸다는 것이다. 일단 인터럽트 핸들러가 끝나면 컴퓨터는 이전에 하던 것으로 돌아갈 수 있다. 인터럽트 핸들러가 충분히 빠르면 핸들러가 사용되었다는 것조차 눈치채지 못할 것이다.

사실, PC에서 이 텍스트를 읽고 있다면, 이 문장을 읽는 데 걸리는 시간 동안, 몇몇 인터럽트 핸들러는 이미 당신의 컴퓨터에 의해 사용되었다. 키보드나 마우스를 사용하거나 인터넷을 통해 데이터를 수신할 때마다 컴퓨터의 어느 지점에서 인터럽트 핸들러가 해당 정보를 검색하는 데 사용되어 왔다.

### 인터럽트 핸들러 

잠시 후 인터럽트 핸들러에 대한 구체적인 세부사항에 대해 알아보겠지만, 이제 나는 그것들이 무엇인지에 대해 설명하고자 한다. 인터럽트 핸들러는 인터럽트가 트리거될 때 어떤 소프트웨어가 실행되어야 하는지 CPU를 정확히 보여주는 방법이다.

8086 CPU는 RAM의 다른 곳에 인터럽트 소프트웨어가 위치한 곳을 "점"으로 설정한 RAM의 일부를 가지고 있다. 이 경로를 통해 CPU는 소프트웨어가 있는 위치를 찾기 위해 간단한 조회만 하면 되고, 그 시점까지 RAM으로 소프트웨어 실행을 전송하면 된다는 이점이 있다. 이것은 또한 프로그래머로서 CPU가 RAM에서 " 가리켜지는" 위치를 변경할 수 있게 해주며, 운영체제의 어떤 것으로 가는 대신, 인터럽트 핸들러를 사용자 지정하고 다른 것을 직접 거기에 넣을 수 있다.

이것이 어떻게 가장 잘 수행되느냐에 따라 운영체제가 크게 달라진다. MS-DOS와 같은 간단한 운영체제의 경우, 이러한 인터럽트 핸들러를 직접 작성하도록 권장하는데, 특히 외부 주변장치와 함께 작업할 때는 더욱 그러하다. 리눅스나 MS-윈도우즈와 같은 다른 운영체제는 이러한 인터럽트 핸들러나 서비스 루틴에 연결되는 "드라이버"를 갖는 접근방식을 사용하고, 그 다음 애플리케이션 소프트웨어는 장비를 직접 다루기보다는 드라이버를 다룬다. 프로그램이 실제로 이를 수행하는 방법은 사용하게 될 특정 운영 체제에 따라 매우 달라진다. 만약 당신이 대신 당신 자신의 운영체제를 쓰려고 한다면, 당신은 이러한 인터럽트 핸들러를 직접 쓰고, 당신이 어떻게 이 핸들러에 접근하여 데이터를 보내고 검색하는지에 대한 프로토콜을 제정해야 할 것이다.

### 소프트웨어 인터럽트 

다음 단계로 넘어가기 전에, 나는 소프트웨어 인터럽트에 대해 아주 간단히 말하고 싶다. 소프트웨어 인터럽트는 다음과 같이 8086 조립 지침 "int"로 호출된다.

int $21

소프트웨어 어플리케이션의 관점에서, 이것은 정말로 서브루틴을 부르는 또 다른 방법일 뿐이지만, 트위스트를 가지고 있다. 인터럽트 핸들러에서 실행되고 있는 "소프트웨어"는 같은 응용 프로그램 또는 심지어 같은 컴파일러에서 만들어질 필요가 없다. 실제로, 종종 이러한 서브루틴들은 조립 언어로 직접 쓰여진다. 위의 예에서 이 인터럽트는 실제로 "DOS" 서브루틴을 호출하여 DOS와 직접 관련된 어떤 종류의 I/O 액세스를 수행할 수 있게 한다. 이 경우 레지스터의 값에 따라, 대개 8086년 AX 레지스터는 현재 시간, 날짜, 디스크 크기, 그리고 일반적으로 DOS와 연관되는 모든 정보와 같은 DOS에서 얻고자 하는 정보를 결정할 수 있다. 컴파일러들은 이런 인터럽트 루틴을 설정하는 것은 약간 까다로울 수 있기 때문에 종종 이런 세부 사항들을 숨긴다.

이제 정말 일을 엉망으로 만드는 거야. "하드웨어 인터럽트"는 "소프트웨어 인터럽트"에서도 호출할 수 있으며, 실제로 이것은 소프트웨어를 올바르게 작성했는지 확인하는 합리적인 방법이다. 여기서의 차이점은 소프트웨어 인터럽트가 이 어셈블리 opcode를 통해 명시적으로 호출된 경우에만 호출되거나 CPU에서 소프트웨어 코드의 일부가 실행된다는 것이다.

### 8259 PIC\(프로그램식 인터럽트 컨트롤러\) 

8259 칩은 하드웨어 인터럽트를 하는 전 과정의 "심장"이다. 외부 장치는 이 칩에 직접 연결되거나 PC-AT 호환 장치의 경우\(현대 PC에서 가장 친숙할 가능성이 높음\) 이러한 두 장치가 함께 연결될 것이다. 문자 그대로 16개의 와이어가 이 칩 쌍에 들어오는데, 각각의 와이어는 IRQ-0에서 IRQ-15로 표시되어 있다.

이러한 칩의 목적은 인터럽트 신호를 "우선"하고 어떤 질서정연하게 정리하는 데 있다. 어떤 장치가 언제 인터럽트를 "요청"할지 예측할 방법이 없기 때문에, 종종 여러 장치가 CPU로부터 주의를 끌기 위해 경쟁할 수 있다.

일반적으로 말해서, 낮은 번호의 IRQ가 우선권을 갖는다. 즉, IRQ-1과 IRQ-4가 동시에 주의를 요청하는 경우 IRQ-1이 우선권을 얻고 CPU에 관한 한 먼저 트리거된다. IRQ-4는 IRQ-1이 "무정전 서비스 절차" 또는 ISR을 완료할 때까지 기다려야 한다.

그러나 IRQ-4가 ISR\(이것은 소프트웨어라는 것을 기억하라, 이것은 당신이 보통 컴퓨터 어플리케이션으로 쓸 수 있는 다른 컴퓨터 프로그램과 마찬가지로\)을 하면서 IRQ-1은 IRQ-4용 ISR을 "방해"하고 대신 실행할 자체 ISR을 밀고, 그것이 끝나면 IRQ-4 ISR로 되돌아간다. 이것에도 예외는 있지만, 현재로서는 일을 단순하게 합시다.

잠시 원래의 IBM-PC로 돌아가 봅시다. 그것이 지어졌을 때, 마더보드에는 8259개의 칩이 하나밖에 없었다. IBM-AT가 출시되었을 때 IBM의 엔지니어들은 IRQ 신호를 추가하기 위해 두 번째 8259 칩을 추가하기로 결정했다. CPU\(현시점 80286\)에는 인터럽트 알림을 받을 수 있는 핀이 아직 1개밖에 없었기 때문에, 원래의 8259 칩에서 IRQ-2를 잡아 다음 칩에 체인으로 묶기로 결정했다. IRQ-2는 IRQ-2에 의존하는 모든 장치에 대해 IRQ-9로 다시 전송되었다. 이 계획을 실행할 때 좋은 점은 IRQ-2를 사용하는 어떤 것을 계획한 소프트웨어가 그 장치를 사용할 때, 비록 7개의 다른 장치가 현재 이 인터럽트를 "공유"하고 있음에도 불구하고, 여전히 "통지"할 것이라는 점이었다. IRQ-8에서 IRQ-15까지 입니다.

그러나 우선순위 측면에서 이것이 의미하는 것은 IRQ-8에서 IRQ-15까지의 우선순위가 IRQ-3보다 높다는 것이다. 이것은 여러분이 어떤 장치가 다른 장치보다 우선할 수 있는지, 그리고 어떤 장비가 여러분의 관심을 끌려고 할 때 얼마나 중요한지를 가려내려고 할 때 주로 걱정된다. 특정 컴퓨터 구성을 실행하는 소프트웨어를 다루는 경우 이 우선 순위 수준은 매우 중요하다.

여기서 주목해야 할 것은 COM1\(시리얼 통신 채널 1\)은 보통 IRQ-4를 사용하며, COM2는 COM1을 통해 데이터를 수신하는 데 더 높은 우선순위가 되도록 하는 순효과를 갖는 IRQ-3을 사용한다는 것이다. 일반적으로 소프트웨어는 정말로 상관하지 않지만, 드물게 이 사실을 알아야 한다.

### 8259 레지스터 

8259에는 I/O 포트 주소와 관련된 "등록기"가 여러 개 있다. 우리는 8250 칩에 도달하면 조금 더 이 컨셉을 방문할 것이다. 일반적인 PC 컴퓨터 시스템의 경우, 8259와 관련된 일반적인 기본 포트 주소는 다음과 같다.

* 인터럽트 컨트롤러 포트 I/O 주소 
* 이름 I/O 포트 등록 
* 마스터 인터럽트 컨트롤러 $0020 
* 슬레이브 인터럽트 컨트롤러 $00A0 

이 1차 포트 주소는 소프트웨어의 8259 칩과 직접 통신하는 데 사용할 것이다. 이러한 I/O 포트 주소를 통해 이 칩에 보낼 수 있는 명령어가 여러 개 있지만, 우리의 목적을 위해 우리는 정말로 그것들을 처리할 필요가 없다. 이 중 대부분은 컴퓨터의 BIOS\(Basic Input Output System\)에 의해 컴퓨터 장비의 초기 설정과 구성을 수행하는 데 사용되며, BIOS를 처음부터 다시 작성하지 않는 한, 정말로 이것에 대해 걱정할 필요가 없다. 또한, 각 컴퓨터는 이 수준에서 장비를 다룰 때 그 동작이 조금씩 다르기 때문에, 이것은 컴퓨터 제조업체가 애플리케이션 프로그래머가 다루어야 할 일보다 더 걱정해야 할 일이며, 이것이 바로 BIOS 소프트웨어가 작성되는 정확한 이유다.

이것은 대부분의 PC 호환형 컴퓨터 시스템의 "일반적인" 포트 I/O 주소이며, 제조업체가 달성하고자 하는 것에 따라 달라질 수 있다는 점을 유념한다. 일반적으로 이 수준에서는 비호환성에 대해 걱정할 필요가 없지만, 직렬 포트의 포트 I/O 주소에 도달하면 이 문제는 훨씬 더 큰 문제가 될 것이다.

### 장치 레지스터 

여기서 잠시 시간을 내어 워드 레지스터의 의미를 설명하려고 한다. 이 수준에서 장비를 다룰 때 장비를 설계한 전기 엔지니어는 장비의 구성을 변경하는 레지스터를 가리킨다. 이런 일은 여러 단계의 추상화에서 일어날 수 있기 때문에, 나는 그 혼동을 어느 정도 해소하고 싶다.

레지스터는 기기가 직접 조작할 수 있는 RAM의 작은 조각일 뿐이다. 8086이나 펜티엄과 같은 CPU에서, 이것들은 두 숫자를 함께 추가하는 것과 같은 수학적인 연산을 직접적으로 수행하는 데 사용되는 기억 영역이다. 이것들은 보통 AX, SP 등과 같은 이름으로 통한다. 이러한 레지스터에 대한 액세스가 기본 기계 수준의 지침으로 직접 암호화되기 때문에 일반적인 CPU에는 레지스터가 거의 없다.

우리가 장치 레지스터에 대해 이야기할 때, 이것들은 CPU 레지스터가 아니라 장치 자체의 메모리 영역이라는 것을 기억하라. 이것들은 종종 포트 I/O 메모리에 연결되도록 설계되므로 포트 I/O 주소에 쓰거나 포트 I/O 주소를 읽을 때 장치 레지스터에 직접 액세스한다. 때로는 더 높은 수준의 추상화가 있을 것이다. 여기서 당신은 당신이 어떤 레지스터를 변경하고 있는지를 나타내는 하나의 포트 I/O 주소와 당신이 그 레지스터로 보낼 데이터를 가진 또 다른 포트 I/O 주소를 갖게 될 것이다. 장치를 다루는 방법은 장치가 얼마나 복잡하고 무엇을 할 것인가에 기초한다.

진정한 의미에서 그것들은 등록부지만, 종종 이러한 장치들은 그 자체로 완전한 컴퓨터라고 여겨질 수 있고, 당신이 하고 있는 것은 그것이 메인 CPU와 어떻게 통신할 것인가를 설정하는 것 뿐이라는 것을 명심하라. 여기에 얽매이지 말고 CPU 레지스터와 헷갈려.

### ISR 정리 

인터럽트 컨트롤러를 사용할 때 정기적으로 상호 작용해야 하는 영역 중 하나는 8259 PIC 컨트롤러에게 인터럽트 서비스 루틴이 완료되었음을 알리는 것이다. 소프트웨어가 인터럽트 핸들러를 수행할 때 CPU가 8259 칩에 신호를 보낼 수 있는 자동화된 방법이 없으므로, 다음 인터럽트 핸들러가 컴퓨터 시스템에 액세스할 수 있도록 PIC의 특정 "등록"을 설정해야 한다. 이를 달성하기 위한 일반적인 소프트웨어는 다음과 같다.

```text
Port[$20] := $20;
```

이것은 "End of Interrupt"라고 불리는 명령어를 전송하거나, 종종 간단히 "EOI"라고 약어로 쓰기도 한다. 이 레지스터에 보낼 수 있는 다른 명령도 있지만, 우리의 목적을 위해서는 이것만이 우리 자신과 관계할 필요가 있다.

이제 이렇게 하면 "마스터" PIC가 지워지지만, "슬레이브" PIC에서 트리거되는 장치를 사용하는 경우, 그 칩에도 인터럽트 서비스가 완료되었음을 알릴 필요가 있다. 이는 "EOI"를 다음과 같은 방식으로 칩에 보내야 한다는 것을 의미한다.



```text
Port[$A0] := $20;
Port[$20] := $20;
```

PIC 장치 마스킹 

8259 PIC의 주제를 떠나기 전에, 나는 기기 마스킹의 개념을 다루고 싶다. PIC에 부착된 각 장치는 PIC 칩을 통해 CPU를 어떻게 중단시킬 수 있느냐는 관점에서 "켜짐" 또는 "꺼짐"이 가능하다. 보통 애플리케이션 개발자로서 우리가 정말 신경쓰는 것은 장치가 켜져 있는지 여부뿐이지만, 성능 문제를 분리하려고 한다면 다른 장치를 끌 수도 있다. 장치를 "끄면" 전원을 다시 켤 때까지 인터럽트가 작동하지 않는다는 점을 명심하십시오. 여기에는 컴퓨터 조작에 필요할 수 있는 키보드나 기타 중요한 장치가 포함될 수 있다.

이 마스크를 설정하는 레지스터를 "작동 제어 워드 1" 또는 "OCW1"이라고 한다. PIC 기본 주소 + 1 또는 포트 I/O 주소 21의 "마스터" PIC에 위치한다. 여기서 비트 조작을 자세히 다루지 않을 겁니다. 다음 표는 각 하드웨어 인터럽트 장치를 활성화 또는 비활성화하기 위해 변경할 관련 비트를 보여준다.



**Master OCW1 \($21\)**

| Bit | IRQ Enabled | Device Function |
| :--- | :--- | :--- |


| 7 | IRQ7 | Parallel Port \(LPT1\) |
| :--- | :--- | :--- |


| 6 | IRQ6 | Floppy Disk Controller |
| :--- | :--- | :--- |


| 5 | IRQ5 | Reserved/Sound Card |
| :--- | :--- | :--- |


| 4 | IRQ4 | Serial Port \(COM1\) |
| :--- | :--- | :--- |


| 3 | IRQ3 | Serial Port \(COM2\) |
| :--- | :--- | :--- |


| 2 | IRQ2 | Slave PIC |
| :--- | :--- | :--- |


| 1 | IRQ1 | Keyboard |
| :--- | :--- | :--- |


| 0 | IRQ0 | System Timer |
| :--- | :--- | :--- |




**Slave OCW1 \($A1\)**

| Bit | IRQ Enabled | Device Function |
| :--- | :--- | :--- |


| 7 | IRQ15 | Reserved |
| :--- | :--- | :--- |


| 6 | IRQ14 | Hard Disk Drive |
| :--- | :--- | :--- |


| 5 | IRQ13 | Math Co-Processor |
| :--- | :--- | :--- |


| 4 | IRQ12 | PS/2 Mouse |
| :--- | :--- | :--- |


| 3 | IRQ11 | PCI Devices |
| :--- | :--- | :--- |


| 2 | IRQ10 | PCI Devices |
| :--- | :--- | :--- |


| 1 | IRQ9 | Redirected IRQ2 Devices |
| :--- | :--- | :--- |


| 0 | IRQ8 | Real Time Clock |
| :--- | :--- | :--- |


IRQ3\(시리얼 포트 COM2의 경우 일반적으로\)을 켜려는 경우를 가정하면 다음 소프트웨어를 사용할 것이다.

```text
 Port[$21] := Port[$21] and $F7; {Clearing bit 3 for enabling IRQ3}
```

그리고 그것을 끄기 위해 우리는 다음과 같은 소프트웨어를 사용할 것이다.

```text
 Port[$21] := Port[$21] or $08; {Setting bit 3 for disabling IRQ3}
```

작업하는 데 문제가 있는 경우 소프트웨어에서 다음 명령을 전송하십시오.

```text
Port[$21] := 0;
```

위 코드는 모든 인터럽트를 가능하게 할 겁니다. 이것은 좋은 일은 아닐지 모르지만, 당신이 무엇을 가지고 작업하느냐에 따라 당신이 실험할 수 있는 무언가가 되어야 할 것이다. 게으른 프로그래머의 징조일 뿐만 아니라 컴퓨터가 의도한 것과는 다르게 행동할 수도 있는 부작용을 일으킬 수 있으므로 이와 같은 단칼을 들이지 않도록 하라. 만약 당신이 이 수준에서 컴퓨터로 작업하고 있다면, 목표는 당신이 사용하고 있는 다른 어떤 소프트웨어에도 손상을 입히지 않도록 가능한 한 적게 바꾸는 것이다.

### 직렬 COM 포트 메모리 및 I/O 할당 

이제 8259 칩을 밀고 나갔으니 UART 자체로 넘어가자. PIC의 포트 I/O 주소는 상당히 표준적이지만, 컴퓨터 제조업체들은 직렬 포트 자체의 물건들을 옮기는 것이 일반적이다. 또한 컴퓨터의 확장 슬롯에 있는 ISA 또는 PCI 카드와 같은 추가 기능 카드의 일부인 직렬 포트 디바이스가 있는 경우 이러한 디바이스는 일반적으로 컴퓨터의 메인 마더보드에 내장된 것과 다른 설정을 가질 수 있다. 이러한 설정을 검색하는 데 시간이 걸릴 수 있으며, 소프트웨어를 작성하려고 할 때 이러한 값이 무엇인지 아는 것이 중요하다. 종종 이러한 값은 컴퓨터의 BIOS 설정 화면에서 찾을 수 있거나, 컴퓨터가 켜질 때 메시지를 일시 중지할 수 있는 경우 컴퓨터의 부팅 프로세스의 일부로 찾을 수 있다.

"일반적인" PC 시스템의 경우, 각 직렬 COM 포트의 포트 I/O 주소와 IRQ는 다음과 같다.

**Common UART IRQ and I/O Port Addresses**

| COM Port | IRQ | Base Port I/O address |
| :--- | :--- | :--- |


| COM1 | IRQ4 | $3F8 |
| :--- | :--- | :--- |


| COM2 | IRQ3 | $2F8 |
| :--- | :--- | :--- |


| COM3 | IRQ4 | $3E8 |
| :--- | :--- | :--- |


| COM4 | IRQ3 | $2E8 |
| :--- | :--- | :--- |


여기서 뭔가 흥미로운 것은, COM3과 COM1이 같은 인터럽트를 공유한다는 것을 알 수 있다. 이것은 실수가 아니라 당신이 인터럽트 서비스 루틴을 쓸 때 명심해야 할 사항이다. 8259 PIC 칩을 통해 사용 가능한 15개의 인터럽트는 여전히 현대 컴퓨터에서 발견되는 모든 장치가 그들만의 개별적인 하드웨어 인터럽트를 가질 수 있도록 하기에는 충분하지 않았으므로, 이 경우에는 다른 장치와 인터럽트를 공유하는 방법을 배울 필요가 있을 것이다. 시리얼 데이터 포트에 액세스하기 위해 실제 소프트웨어에 들어가면 나중에 더 자세히 다루겠지만, 지금은 한 장치에만 소프트웨어를 엄격하게 쓰지 않도록 하는 것을 기억하십시오.

기본 포트 I/O 주소는 UART 레지스터에 직접 액세스하는 다음 주제를 위해 중요하다.

### UART 레지스터 

UART 칩은 총 12개의 서로 다른 레지스터를 가지고 있으며 8개의 다른 포트 I/O 위치에 매핑되어 있다. 네, 8개소에 12개의 레지스터가 있는데 이는 분명히 동일한 포트 I/O 위치를 사용하는 레지스터가 두 개 이상 있다는 것을 의미하며 UART 구성 방법에 영향을 미친다. 실제로는 두 개의 레지스터가 실제로 동일하지만 다른 맥락에서, 직렬 데이터 포트에서 보낼 문자를 전송하는 포트 I/O 주소가 컴퓨터로 전송되는 문자에서 읽을 수 있는 주소와 동일하기 때문이다. 다른 I/O 포트 주소는 데이터를 쓸 때 데이터를 읽을 때와는 다른 컨텍스트를 갖는다. 그리고 그 숫자들은 당신이 그것으로부터 데이터를 읽을 때와는 그것에 데이터를 쓴 후에 다를 것이다. 그것에 대해 조금 더 얘기해보자.

이 칩이 원래 설계되었을 때 제기된 문제 중 하나는 설계자가 16비트로 직렬 데이터의 보드 레이트에 대한 정보를 보낼 수 있어야 한다는 것이었습니다. 이것은 실제로 두 개의 서로 다른 "등록자"를 차지하며, "디비소 래치 액세스 비트" 또는 "DLAB"라고 불리는 것으로 토글된다. DLAB를 "1"로 설정하면 보드 레이트 레지스터를 설정할 수 있으며, "0"일 때는 레지스터의 컨텍스트가 다르다.

이 모든 것이 혼란스럽게 들리는가? 그럴 수도 있지만, 한 번에 하나의 간단한 조각으로 하자. 다음은 일반적인 UART 칩에서 찾을 수 있는 각 레지스터의 표다.

**UART Registers**

| Base Address | DLAB | I/O Access | Abbrv. | Register Name |
| :--- | :--- | :--- | :--- | :--- |


| +0 | 0 | Write | THR | Transmitter Holding Buffer |
| :--- | :--- | :--- | :--- | :--- |


| +0 | 0 | Read | RBR | Receiver Buffer |
| :--- | :--- | :--- | :--- | :--- |


| +0 | 1 | Read/Write | DLL | Divisor Latch Low Byte |
| :--- | :--- | :--- | :--- | :--- |


| +1 | 0 | Read/Write | IER | Interrupt Enable Register |
| :--- | :--- | :--- | :--- | :--- |


| +1 | 1 | Read/Write | DLH | Divisor Latch High Byte |
| :--- | :--- | :--- | :--- | :--- |


| +2 | x | Read | IIR | Interrupt Identification Register |
| :--- | :--- | :--- | :--- | :--- |


| +2 | x | Write | FCR | FIFO Control Register |
| :--- | :--- | :--- | :--- | :--- |


| +3 | x | Read/Write | LCR | Line Control Register |
| :--- | :--- | :--- | :--- | :--- |


| +4 | x | Read/Write | MCR | Modem Control Register |
| :--- | :--- | :--- | :--- | :--- |


| +5 | x | Read | LSR | Line Status Register |
| :--- | :--- | :--- | :--- | :--- |


| +6 | x | Read | MSR | Modem Status Register |
| :--- | :--- | :--- | :--- | :--- |


| +7 | x | Read/Write | SR | Scratch Register |
| :--- | :--- | :--- | :--- | :--- |


DLAB 열의 "x"는 DLAB의 상태가 해당 오프셋 범위에서 액세스할 레지스터에 영향을 미치지 않음을 의미한다. 또한 일부 레지스터는 읽기 전용이라는 점에 유의하십시오. 만약 당신이 그들에게 데이터를 쓰려고 한다면, 당신은 모뎀에 약간의 문제가 생기거나\(최악의 경우\) 그 데이터는 간단히 무시될 것이다\(일반적으로 결과\). 앞에서 언급한 바와 같이, 일부 레지스터는 데이터를 기록할 때 하나의 레지스터가 사용될 포트 I/O 주소를 공유하고 있으며, 동일한 주소에서 데이터를 검색하는 데 다른 레지스터가 사용될 것이다.

각 직렬 통신 포트에는 자체적인 등록기 집합이 있다. 예를 들어 COM1에 대한 LSR\(Line Status Register\)에 액세스하고 기본 I/O Port 주소를 3F8로 가정하면 이 레지스터의 정보를 얻기 위한 I/O Port 주소는 3F8 + 05 또는 3FD로 확인될 수 있다. 일부 예제 코드는 다음과 같다.

```text
const
  COM1_Base = $3F8;
  COM2_Base = $2F8;
  LSR_Offset = $05;

function LSR_Value: Byte;
begin
  Result := Port[COM1_Base+LSR_Offset];
end;
```

이들 각 레지스터에는 꽤 많은 정보가 들어 있으며, 다음은 각 레지스터의 의미와 그 안에 들어 있는 정보에 대한 설명이다.

### 송신기 홀딩 버퍼/수신기 버퍼 

 오프셋: +0 . 송신 버퍼와 수신 버퍼는 관련이 있으며, 심지어 매우 동일한 메모리를 사용하는 경우가 많다. 이것은 또한 후기 모델들이 직렬 데이터로 전송되기 전에 칩 안에 있는 데이터의 내부 버퍼링을 일부 포함하고 있기 때문에 8250 칩의 후기 버전들이 상당한 영향을 미치는 영역들 중 하나이다. 기본 8250 칩은 한 번에 한 바이트만 수신할 수 있는 반면, 16550 칩과 같은 칩은 전송하거나 수신하기 위해 최대 16바이트까지 보유하게 된다\(때로는 두 가지 모두...\). 문자를 보낼 때까지 기다려야 하기 전에 제조업체에 따라 달라진다. 이것은 컴퓨터가 많은 일을 하는 다중 작업 환경에서 유용할 수 있으며, 직렬 데이터 흐름을 처리하기까지는 몇 밀리초가 걸릴 수 있다.

이러한 레지스터는 실제로 직렬 데이터 통신의 "심장"이며, 데이터가 소프트웨어에서 다른 컴퓨터로 전송되는 방법과 다른 장치에서 데이터를 얻는 방법이다. 이러한 레지스터에 대한 읽기 및 쓰기는 단순히 각각의 UART에 대한 포트 I/O 주소에 액세스하는 문제일 뿐이다.

수신 버퍼가 사용되거나 FIFO가 가득 차면 수신 데이터가 삭제되고 수신기 라인 상태 인터럽트가 IIR 레지스터에 기록된다. 오버런 오류 비트는 라인 상태 레지스터에서도 설정된다.

### Divisor 래치 

오프셋: +0과 +1 . Divisor Latch Bytes는 모뎀의 보드 속도를 제어하는 것이다. 이 레지스터의 이름에서 추측할 수 있듯이, 칩이 송신할 보레이트를 결정하기 위해 점수로 사용된다.

실제로는 그것보다 더 간단하다. 이것은 정말로 UART에 의해 비트가 전송될 때마다 사용되는 카운트다운 시계다. 비트가 전송될 때마다 카운트다운 레지스터가 이 값으로 재설정되고 0으로 카운트 다운된다. 이 시계는 일반적으로 115.2KHz로 작동한다. 즉, 초당 11만 5천 번으로 카운터가 내려가 다음 비트를 언제 보낼지 결정한다는 것이다. 한때 설계 프로세스 중에 UART 작동을 위해 다른 주파수를 사용할 수 있을 것으로 예상되었지만, 이 칩에 대해 이미 쓰여진 많은 양의 소프트웨어 때문에 이 주파수는 PC 플랫폼에서 사용되는 거의 모든 UART 칩에 대해 상당히 표준적이다. 그들은 \(1.843 MHz 클럭과 같은\) 일부에서 더 빠른 클럭을 사용할 수 있지만, 그 주파수의 일부분은 115.2 KHz 클럭으로 확장하는 데 사용될 것이다.

UART 클럭 속도\(고급 적용 범위\): 많은 UART 칩의 경우, UART를 구동하는 클럭 주파수는 1.8432 MHz이다. 이 주파수는 16배만큼 주파수를 떨어뜨리는 분할 회로를 통해 전달되며, 이는 위에서 언급한 115.2KHz 주파수를 우리에게 제공한다. 만약 당신이 이 칩을 사용하여 몇몇 맞춤 장비를 한다면, National Semiconductor 사양 시트는 3.072 MHz 시계와 18.432 MHz 시계를 허용한다. 이러한 높은 주파수는 더 높은 보드 속도로 통신할 수 있게 해주지만, 이러한 새로운 주파수를 처리하기 위해 마더보드에 사용자 지정 회로와 종종 새로운 드라이버가 필요하다. 흥미로운 것은 이러한 더 높은 클럭 주파수로 50보에서 여전히 작동할 수 있다는 것이지만, 원래의 IBM-PC/XT가 제조되었을 때 이것은 더 높은 데이터 처리량에 있어 지금처럼 큰 문제는 아니었다.

다음 수학 공식을 사용할 경우, Divisor Latch Bytes에 넣어야 할 숫자를 결정할 수 있다.

{\displaystyle {DivisorLatchValue}={115200 \over {BaudRate}}{\displaystyle {DivisorLatchValue}={115200 \over {BaudRate}}}} 

이 표는 직렬 통신의 일반적인 보드 속도를 결정하는 데 사용할 수 있는 다음 표를 제공한다.

**Divisor Latch Byte Values \(common baud rates\)**

| Baud Rate | Divisor \(in decimal\) | Divisor Latch High Byte | Divisor Latch Low Byte |
| :--- | :--- | :--- | :--- |


| 50 | 2304 | $09 | $00 |
| :--- | :--- | :--- | :--- |


| 110 | 1047 | $04 | $17 |
| :--- | :--- | :--- | :--- |


| 220 | 524 | $02 | $0C |
| :--- | :--- | :--- | :--- |


| 300 | 384 | $01 | $80 |
| :--- | :--- | :--- | :--- |


| 600 | 192 | $00 | $C0 |
| :--- | :--- | :--- | :--- |


| 1200 | 96 | $00 | $60 |
| :--- | :--- | :--- | :--- |


| 2400 | 48 | $00 | $30 |
| :--- | :--- | :--- | :--- |


| 4800 | 24 | $00 | $18 |
| :--- | :--- | :--- | :--- |


| 9600 | 12 | $00 | $0C |
| :--- | :--- | :--- | :--- |


| 19200 | 6 | $00 | $06 |
| :--- | :--- | :--- | :--- |


| 38400 | 3 | $00 | $03 |
| :--- | :--- | :--- | :--- |


| 57600 | 2 | $00 | $02 |
| :--- | :--- | :--- | :--- |


| 115200 | 1 | $00 | $01 |
| :--- | :--- | :--- | :--- |


표를 볼 때 한 가지 명심해야 할 것은 보레이트 600 이상, 무엇보다도 디비소 래치 하이 바이트를 0으로 설정했다는 점이다. 어설픈 프로그래머는 아무도 그렇게 낮은 보레이트를 다루지 않을 것이라고 가정할 때 높은 바이트 설정을 건너뛰려고 할 수도 있지만, 이것은 항상 추측할 수 있는 것은 아니다. 좋은 프로그래밍 습관은 여러분이 하고 있는 모든 것이 더 높은 보레이트로 실행되더라도 이것을 0으로 설정하도록 노력해야 한다는 것을 암시한다.

또 하나 주목해야 할 것은 위에 나열된 표준 보레이트 이외의 다른 잠재적 보레이트가 있다는 것이다. 이것은 전형적인 응용에는 권장되지 않지만, 실험에는 재미있는 것이 될 것이다. 또한 표준 API 라이브러리가 호환되어야 하는 특정 보드 속도를 허용하지 않는 이러한 방식으로 구형 장비와 통신을 시도할 수 있다. 이것은 왜 이 수준의 칩에 대한 지식이 여전히 매우 유용한지를 증명해야 한다.

이러한 레지스터로 작업할 때, Divisor Latch Access Bit를 "1"로 설정해야 하는 유일한 레지스터라는 것도 기억하십시오. 아래 내용은 더 자세히 설명하겠지만, 애플리케이션 소프트웨어가 보레이트를 즉시 변경하기 위해 DLAB를 "1"로 설정한 다음, 모뎀에 대한 I/O 액세스를 더 하기 바로 다음 단계로 되돌리는 것이 유용할 것이다. 이것은 단지 좋은 작업 습관일 뿐이며, UART에 접근하기 위해 필요한 나머지 소프트웨어를 훨씬 깨끗하고 쉽게 유지한다.

한 마디 주의: 두 Divisor Latch 바이트에 대해 값을 "0"으로 설정하지 마십시오. UART 칩을 손상시키지는 않겠지만, UART가 직렬 데이터를 전송하는 방법은 예측할 수 없으며, 한 컴퓨터에서 다른 컴퓨터로, 혹은 컴퓨터를 부팅할 때 한 번에서 다른 컴퓨터로 바뀔 것이다. 이는 오류 조건이며, 이 수준에서 보드 속도 설정과 함께 작동하는 소프트웨어를 작성하는 경우, Divisor Latch의 잠재적인 "0" 값을 포착해야 한다.

여기 COM1의 보드 속도를 설정하고 검색하는 몇 가지 샘플 소프트웨어가 있다.

```text
const
  COM1_Base = $3F8;
  COM2_Base = $2F8;
  LCR_Offset = $03;
  Latch_Low = $00;
  Latch_High = $01;

procedure SetBaudRate(NewRate: Word);
var
  DivisorLatch: Word;
begin
  DivisorLatch := 115200 div NewRate;
  Port[COM1_Base + LCR_Offset] := Port[COM1_Base + LCR_Offset] or $80; {Set DLAB}
  Port[COM1_Base + Latch_High] := DivisorLatch shr 8;
  Port[COM1_Base + Latch_Low] := DivisorLatch and $FF;
  Port[COM1_Base + LCR_Offset] := Port[COM1_Base + LCR_Offset] and $7F; {Clear DLAB}
end;

function GetBaudRate: Integer;
var
  DivisorLatch: Word;
begin
  Port[COM1_Base + LCR_Offset] := Port[COM1_Base + LCR_Offset] or $80; {Set DLAB}
  DivisorLatch := (Port[COM1_Base + Latch_High] shl 8) + Port[COM1_Base + Latch_Low];
  Port[COM1_Base + LCR_Offset] := Port[COM1_Base + LCR_Offset] and $7F; {Clear DLAB}
  Result := 115200 div DivisorLatch;
end;
```

### 인터럽트 활성화 레지스터 

오프셋: +1 . 이 레지스터를 사용하면 UART가 시리얼 COM 포트에 연결된 하드웨어 인터럽트로 인터럽트 이벤트를 트리거하는 시기와 방법을 제어할 수 있다. 이를 적절하게 사용하면 시스템 자원을 효율적으로 사용할 수 있으며, 기본적으로 실시간 조건에서 직렬 데이터 라인을 통해 전송되는 정보에 대응할 수 있다. 그 부분에 대해서는 나중에 더 다루겠지만 여기서 중요한 것은 UART를 사용하여 언제 어떤 데이터를 추출해야 하는지 정확히 알려줄 수 있다는 겁니다. 이 레지스터에는 읽기 및 쓰기 액세스 권한이 있다.

다음은 이 레지스터의 각 비트 및 이 칩의 상태를 확인할 수 있는 이벤트를 보여 주는 표입니다.

**Interrupt Enable Register \(IER\)**

| Bit | Notes |
| :--- | :--- |


| 7 | Reserved |
| :--- | :--- |


| 6 | Reserved |
| :--- | :--- |


| 5 | Enables Low Power Mode \(16750\) |
| :--- | :--- |


| 4 | Enables Sleep Mode \(16750\) |
| :--- | :--- |


| 3 | Enable Modem Status Interrupt |
| :--- | :--- |


| 2 | Enable Receiver Line Status Interrupt |
| :--- | :--- |


| 1 | Enable Transmitter Holding Register Empty Interrupt |
| :--- | :--- |


| 0 | Enable Received Data Available Interrupt |
| :--- | :--- |


Received Data interrupt는 UART에서 철수하기 위해 대기하고 있는 일부 데이터가 있음을 알려 주는 방법이다. 이것은 아마도 나머지 부분보다 더 많이 사용할 것이고, 더 많이 사용할 것이다.

송신기 홀딩 레지스터 빈 인터럽트는 \(16550과 같은 더 진보된 칩 모델에 대한\) 출력 버퍼가 버퍼에 밀어넣은 모든 것을 전송하는 것을 완료했음을 알려 주는 것이다. 이는 데이터 전송 루틴을 간소화하여 CPU 시간을 줄이는 방법이다.

수신기 라인 상태 인터럽트는 LSR 레지스터의 내용이 변경되었을 가능성이 있음을 나타낸다. 이것은 보통 오류 조건이며, 애플리케이션의 최종 사용자에게 일반 텍스트 설명을 제공하는 UART의 효율적인 오류 처리기를 작성하려면 이 사항을 고려해야 한다. 이것은 확실히 프로그래밍에 대한 좀 더 진보된 지식을 필요로 하는 것이다.

모뎀 상태 인터럽트는 컴퓨터에 연결된 외부 모뎀이 변경될 때 이를 알려 주는 것이다. 여기에는 전화 "벨" 울림\(소프트웨어에서 이 것을 시뮬레이션할 수 있음\), 다른 모뎀에 성공적으로 연결한 것\(통신사 감지가 켜져 있음\) 또는 누군가가 전화를 "충전"한 것\(통신사 감지가 꺼짐\)과 같은 것이 포함될 수 있다. 또한 외부 모뎀이나 데이터 장비가 계속해서 데이터를 수신할 수 있는지 여부를 알 수 있다\(보낼 때 삭제\). 본질적으로, 이것은 엄격하게 송수신선을 제외한 RS-232 표준의 다른 와이어를 다룬다.

다른 두 가지 모드는 엄격히 16750 칩을 위한 것이며, 이 칩을 "저전력" 상태로 전환하여 노트북 컴퓨터나 배터리처럼 매우 제한된 전력을 가진 임베디드 컨트롤러와 같은 것에 사용할 수 있도록 돕는다. 이전의 칩에서는 이러한 비트를 "예약된" 것으로 간주하고 "0"만 넣어야 한다.

### 인터럽트 식별 레지스터 

오프셋: +2 . 이 레지스터는 사용 중인 UART 칩의 고유한 특성이 무엇인지 식별하는 데 유용하게 사용된다. 이 칩에는 두 가지 용도가 있다.

UART가 중단을 유발한 이유 확인. UART 칩 자체의 식별. 이 중에서 인터럽트 서비스 루틴이 호출된 이유를 확인하는 것이 아마도 가장 중요할 것이다.

다음 표에서는 이 레지스터의 일부 세부사항과 여기에 있는 각 비트가 무엇을 나타내는지 설명한다.



**Interrupt Identification Register \(IIR\)**

| Bit | Notes |
| :--- | :--- |


| 7 and 6 | Bit 7 | Bit 6 |  |
| :--- | :--- | :--- | :--- |


| 0 | 0 | No FIFO on chip |
| :--- | :--- | :--- |


| 0 | 1 | Reserved condition |
| :--- | :--- | :--- |


| 1 | 0 | FIFO enabled, but not functioning |
| :--- | :--- | :--- |


| 1 | 1 | FIFO enabled |
| :--- | :--- | :--- |


| 5 | 64 Byte FIFO Enabled \(16750 only\) |
| :--- | :--- |


| 4 | Reserved |
| :--- | :--- |


| 3, 2 and 1 | Bit 3 | Bit 2 | Bit 1 |  | Reset Method |
| :--- | :--- | :--- | :--- | :--- | :--- |


| 0 | 0 | 0 | Modem Status Interrupt | Reading Modem Status Register\(MSR\) |
| :--- | :--- | :--- | :--- | :--- |


| 0 | 0 | 1 | Transmitter Holding Register Empty Interrupt | Reading Interrupt Identification Register\(IIR\) or Writing to Transmit Holding Buffer\(THR\) |
| :--- | :--- | :--- | :--- | :--- |


| 0 | 1 | 0 | Received Data Available Interrupt | Reading Receive Buffer Register\(RBR\) |
| :--- | :--- | :--- | :--- | :--- |


| 0 | 1 | 1 | Receiver Line Status Interrupt | Reading Line Status Register\(LSR\) |
| :--- | :--- | :--- | :--- | :--- |


| 1 | 0 | 0 | Reserved | N/A |
| :--- | :--- | :--- | :--- | :--- |


| 1 | 0 | 1 | Reserved | N/A |
| :--- | :--- | :--- | :--- | :--- |


| 1 | 1 | 0 | Time-out Interrupt Pending \(16550 & later\) | Reading Receive Buffer Register\(RBR\) |
| :--- | :--- | :--- | :--- | :--- |


| 1 | 1 | 1 | Reserved | N/A |
| :--- | :--- | :--- | :--- | :--- |


| 0 | Interrupt Pending Flag |
| :--- | :--- |


250 칩에 대한 인터럽트 핸들러를 작성하는 경우\(그리고 나중에\), 인터럽트의 트리거가 정확히 무엇인지 판단하기 위해 살펴봐야 할 레지스터 입니다.

앞에서 설명한 바와 같이 복수의 직렬 통신기기는 동일한 하드웨어 인터럽트를 공유할 수 있다. 이 레지스터의 "비트 0"을 사용하면 이것이 실제로 방해를 일으킨 장치라는 것을 알 수 있다\(또는 확인\). 모든 직렬 장치\(별도의 포트 I/O 주소 공간에 있음\)를 확인하고 이 레지스터의 내용을 가져오십시오. 두 개 이상의 장치가 동시에 인터럽트를 발생시킬 수 있으므로, 시리얼 장치에 대한 이 스캔을 수행할 때는 모든 장치를 검사하십시오. 실제로 첫 번째 장치 중 하나라도 처리해야 한다는 점을 명심하십시오. 어떤 컴퓨터 시스템은 이런 일이 일어나지 않도록 할 수도 있지만, 어쨌든 이것은 좋은 프로그래밍 연습이다. 또한 UART를 더 일찍 처리한 방법 때문에 주어진 인터럽트에 대해 모든 UART를 이미 처리했을 수도 있다. 이 비트가 "0"일 때, UART가 인터럽트를 트리거하고 있음을 확인한다. "1"인 경우, 이는 인터럽트가 이미 처리되었거나 이 특정 UART가 트리거 장치가 아니라는 것을 의미한다. 나는 이것이 컴퓨터에 사용되는 전형적인 비트 플래그에게는 약간 뒤처져 보인다는 것을 알지만, 이것을 디지털 로직이라고 하며, 전기 회로 설계에서 상당히 흔하다. 이 논리 패턴이 소프트웨어 영역으로 들어가는 것은 좀 더 이례적이다.

비트 1, 2 및 3은 UART 내에서 어떤 종류의 인터럽트 이벤트가 하드웨어 인터럽트를 호출하는 데 사용되었는지 정확하게 식별하는 데 도움이 된다. 이것들은 IER 레지스터로 이전에 활성화되었던 것과 같은 인터럽트들이다. 그러나 이 경우, 당신이 레지스터를 처리하고 인터럽트를 처리할 때마다 그것은 독특할 것이다. UART에 대해 여러 가지 일이 동시에 발생하여 복수의 "트리거"가 발생할 경우, 복수의 하드웨어 인터럽트를 통해 호출된다. 이전의 칩 세트는 비트 3을 사용하지 않지만, 이것은 UART 시스템에서 예약된 비트로서 항상 논리 상태 "0"으로 설정되므로, 어떤 인터럽트가 사용되었는지 해독하려고 할 때 프로그래밍 논리는 다를 필요가 없다.

FIFO 시간 초과 인터럽트를 설명하기 위해, 이것은 패킷의 끝이나 들어오는 데이터 스트림이 중지되었는지 확인하는 방법이다. 일반적으로 이 인터럽트를 트리거하려면 다음 조건이 존재해야 한다. 일부 데이터는 들어오는 FIFO에 있어야 하며 컴퓨터에 의해 읽혀지지 않았다. 직렬 데이터 링크를 통해 UART로 전송되는 데이터 전송은 새로운 문자를 수신하지 않고 종료되어야 한다. CPU가 들어오는 데이터를 처리하는 것은 시간 초과가 발생하기 전에 FIFO에서 어떤 데이터도 검색하지 않아야 한다. 시간 제한은 일반적으로 최소 4자 이상의 문자를 전송하거나 수신하는 데 걸리는 시간 이후에 발생한다. 1200baud, 8개의 데이터 비트, 2개의 정지 비트, 홀수 패리티로 전송되는 데이터에 대해 이야기한다면, 약 40밀리초가 소요될 것이며, 이는 컴퓨터가 4GHz Pentium CPU로 수행할 수 있는 작업으로 볼 때 거의 영원할 겁니다.

위에 열거된 "리셋 방법"은 UART가 주어진 인터럽트가 처리되었음을 통지하는 방법을 설명한다. 재설정 방법에 따라 언급된 레지스터에 액세스하면 UART의 인터럽트 상태가 삭제된다. 동일한 UART에 대해 여러 인터럽트가 트리거된 경우 CPU의 인터럽트 신호\(완료 시 새 하드웨어 인터럽트 트리거\)가 삭제되지 않거나 이 레지스터\(IIR\)로 돌아가서 인터럽트 보류 플래그에 쿼리하여 처리할 인터럽트가 더 있는지 확인하여 새로운 문제를 해결하십시오. 적절한 애플리케이션 코드를 사용하여 처리해야 할 수 있는 문제를 중단하십시오.

비트 5, 6 및 7은 문자를 주고받는 데 사용되는 FIFO 버퍼의 현재 상태를 보고하고 있다. 최초의 16550 칩 설계는 FIFO에 심각한 결함이 있는 버그가 처음 출시되었을 때 있었고, 이로 인해 FIFO는 그것이 작동하고 있다고 보고했지만 사실은 그렇지 않았다. 일부 소프트웨어는 이미 FIFO와 함께 작동하도록 작성되었기 때문에, 이 비트\(본 레지스터의 비트 7\)는 유지되었지만, 16550 칩의 이전 버전에 있는 하드웨어 FIFO를 일부 새로운 소프트웨어가 무시하려는 경우에 대비해, 실제로 FIFO가 제대로 작동하고 있음을 확인하기 위해 비트 6을 추가하였다. 이 패턴은 이 칩의 미래 버전에서도 유지되었다. 16750 칩에는 64바이트 FIFO가 추가되었으며, 비트 5는 이 확장 버퍼의 존재를 지정하는 데 사용된다. 이러한 FIFO 버퍼는 아래에 나열된 레지스터를 사용하여 켜고 끌 수 있다.

### FIFO 제어 레지스터 

오프셋: +2 . 본래의 8250 UART 구현에는 포함되지 않았던 비교적 "신규" 레지스터 입니다. 이 레지스터의 목적은 FIFO\(First In/First Out\) 버퍼가 칩에서 작동하는 방식을 제어하고 응용 프로그램에서 성능을 미세 조정하는 데 도움을 주기 위한 것이다. 이것은 심지어 당신에게 FIFO를 "켜"거나 "끄는" 능력을 준다.

이것은 "쓰기 전용" 레지스터라는 것을 명심하라. 내용을 읽으려고 하면 전혀 다른 맥락의 인터럽트 식별 레지스터\(IIR\)만 준다.

**FIFO Control Register \(FCR\)**

| Bit | Notes |
| :--- | :--- |


| 7 & 6 | Bit 7 | Bit 6 | Interrupt Trigger Level \(16 byte\) | Trigger Level \(64 byte\) |
| :--- | :--- | :--- | :--- | :--- |


| 0 | 0 | 1 Byte | 1 Byte |
| :--- | :--- | :--- | :--- |


| 0 | 1 | 4 Bytes | 16 Bytes |
| :--- | :--- | :--- | :--- |


| 1 | 0 | 8 Bytes | 32 Bytes |
| :--- | :--- | :--- | :--- |


| 1 | 1 | 14 Bytes | 56 Bytes |
| :--- | :--- | :--- | :--- |


| 5 | Enable 64 Byte FIFO \(16750\) |
| :--- | :--- |


| 4 | Reserved |
| :--- | :--- |


| 3 | DMA Mode Select |
| :--- | :--- |


| 2 | Clear Transmit FIFO |
| :--- | :--- |


| 1 | Clear Receive FIFO |
| :--- | :--- |


| 0 | Enable FIFOs |
| :--- | :--- |


비트 0에 "0"을 쓰면 FIFO가 비활성화되며, 본질적으로 UART를 8250 호환성 모드로 전환한다. 사실상 이것은 또한 이 레지스터의 나머지 설정을 쓸모 없게 만든다. 여기서 "0"을 작성하면 FIFO가 데이터를 송신하거나 수신하지 못하게 되므로, 이 설정을 변경한 후 직렬 데이터 포트를 통해 전송되는 모든 데이터가 스크램블될 수 있다. 시리얼 통신 프로토콜을 재설정하고 애플리케이션 소프트웨어에 있을 수 있는 작동 버퍼를 지우려는 경우에만 FIFO를 비활성화하는 것이 좋다. 일부 문서에서는 이 비트를 "0"으로 설정하면 FIFO 버퍼도 지워지지만 비트 1과 2를 사용하는 대신 명시적인 버퍼 삭제를 권장한다.

비트 1과 2는 내부 FIFO 버퍼를 청소하는 데 사용된다. 이 기능은 UART를 사용하는 이전 소프트웨어에서 "뒤쳐진" 데이터를 삭제하려는 응용 프로그램을 처음 시작할 때 또는 통신 연결을 재설정하려는 경우에 유용하다. 이러한 비트는 "자동으로" 재설정되므로, 이 중 하나를 논리적인 "1" 상태로 설정하면 나중에 "0"으로 되돌릴 필요가 없다. 논리적인 "0"을 보내는 것은 FIFO 제어의 다른 측면이 변경되더라도 UART에게 FIFO 버퍼를 재설정하지 말라고 말할 뿐이다.

비트 3은 주로 FIFO에서 데이터를 검색하려고 할 때 DMA\(Direct Memory Access\)가 발생하는 방식에 관한 것이다. 이는 주로 직렬 데이터에 직접 액세스하여 내부 버퍼에 이 데이터를 저장하려는 칩 설계자에게 유용할 것이다. UART 칩 자체에 RXRDY와 TXRDY라는 두 개의 디지털 로직 핀이 있다. UART 칩으로 컴퓨터 회로를 설계하려고 한다면 이것은 유용할 수도 있고 심지어 중요할 수도 있지만, PC 시스템의 응용 프로그램 개발자의 목적상 그것은 거의 쓸모가 없고 당신은 안전하게 무시할 수 있다.

비트 5는 16750 UART 칩이 버퍼를 16바이트에서 64바이트로 확장할 수 있게 해준다. 이는 버퍼의 크기에 영향을 줄 뿐만 아니라 다음에 기술한 트리거 임계값의 크기도 제어한다. 이전의 칩 타입에서는 이것은 예약된 비트로서 논리적인 "0" 상태로 유지되어야 한다. 16750년에는 16550년에 비해 UART가 165 바이트 FIFO와 더 흡사하게 공연된다.

비트 6과 7은 트리거 임계값에 대해 설명한다. 이것은 FIFO에서 데이터를 제거해야 한다는 것을 알려주는 인터럽트가 트리거되기 전에 FIFO에 저장될 문자 수입니다. 시리얼 데이터 링크를 통해 대량의 데이터가 전송될 것으로 예상할 경우 버퍼 크기를 늘릴 수 있다. 트리거의 최대값이 FIFO 버퍼 크기보다 작은 이유는 일부 소프트웨어가 UART에 접속해 데이터를 검색하는 데 다소 시간이 걸릴 수 있기 때문이다. FIFO가 가득 차면 FIFO의 데이터가 손실되기 시작하므로 이 임계값에 도달한 후 데이터를 검색했는지 확인하는 것이 중요하다는 점을 기억하십시오. UART 데이터를 검색하는 동안 소프트웨어 타이밍에 문제가 발생하는 경우 임계값을 낮추고 싶을 수 있다. 임계값이 1바이트로 설정된 극한 끝부분에서는 기본적으로 기본 8250과 같은 역할을 하지만, 일부 캐릭터는 즉시 모든 것을 얻을 기회가 없는 상황에서 버퍼에 걸릴 수 있다는 추가 신뢰도를 가지고 있다.

### 라인 제어 레지스터 

오프셋: +3 . 이 레지스터는 두 가지 주요 목적을 가지고 있다.

DLAB\(Divisor Latch Access Bit\) 설정으로, Divisor Latch Bytes 값을 설정할 수 있다. 직렬 데이터 수신 및 전송에 사용할 비트 패턴 설정. 즉, 사용할 직렬 데이터 프로토콜\(8-1-없음, 5-2- 짝수 등\).

**Line Control Register \(LCR\)**

| Bit | Notes |
| :--- | :--- |


| 7 | Divisor Latch Access Bit |
| :--- | :--- |


| 6 | Set Break Enable |
| :--- | :--- |


| 3, 4 & 5 | Bit 5 | Bit 4 | Bit 3 | Parity Select |
| :--- | :--- | :--- | :--- | :--- |


| 0 | 0 | 0 | No Parity |
| :--- | :--- | :--- | :--- |


| 0 | 0 | 1 | Odd Parity |
| :--- | :--- | :--- | :--- |


| 0 | 1 | 1 | Even Parity |
| :--- | :--- | :--- | :--- |


| 1 | 0 | 1 | Mark |
| :--- | :--- | :--- | :--- |


| 1 | 1 | 1 | Space |
| :--- | :--- | :--- | :--- |


| 2 | 0 | One Stop Bit |
| :--- | :--- | :--- |


| 1 | 1.5 Stop Bits or 2 Stop Bits |
| :--- | :--- |


| 0 & 1 | Bit 1 | Bit 0 | Word Length |
| :--- | :--- | :--- | :--- |


| 0 | 0 | 5 Bits |
| :--- | :--- | :--- |


| 0 | 1 | 6 Bits |
| :--- | :--- | :--- |


| 1 | 0 | 7 Bits |
| :--- | :--- | :--- |


| 1 | 1 | 8 Bits |
| :--- | :--- | :--- |


첫 번째 두 비트\(비트 0과 비트 1\)는 직렬 프로토콜을 통해 전송되는 각 데이터 "워드"에 대해 전송되는 데이터 비트의 수를 제어한다. 대부분의 직렬 데이터 전송의 경우 8비트가 되지만, 데이터 비트가 더 적게 필요한 일부 이전 프로토콜과 구형 장비를 찾을 수 있다. 예를 들어, 일부 군사용 암호화 장비는 일부 TELEX 장비와 마찬가지로 직렬 "워드"당 5개의 데이터 비트만 사용한다. 초기 ASCII 텔레타이프 단자는 7개의 데이터 비트만 사용했으며, 실제로 이 유산은 이메일 메시지에 7비트 ASCII만 사용하는 SMTP 형식으로 보존되어 왔다. 분명히 이것은 당신이 RS-232 프로토콜을 사용하여 성공적으로 메시지 전송을 완료하기 전에 확립되어야 할 것이다.

비트 2는 UART에 의해 수신 장치로 전송되는 정지 비트의 수를 제어한다. 이것은 1개의 정지 비트를 나타내는 논리적인 "0"과 2개의 정지 비트를 나타내는 "1" 중 하나로 선택 가능하다. 5개의 데이터 비트의 경우, UART는 대신 "1.5 정지 비트"를 전송한다. 이러한 맥락에서 '비트'는 실제로 시간 간격임을 기억하십시오. 각 비트는 50보\(초당 비트 수\)에서 20ms가 걸린다는 점을 기억하십시오. 따라서 "1.5 정지 비트"는 문자 사이에 최소 30ms를 가질 것이다. 이는 7비트 또는 8비트 ASCII가 아닌 5비트 Baudot를 사용한 장비만 "1.5 정지 비트"를 사용했기 때문에 "5 데이터 비트" 설정과 연관된다.

또 한 가지 유의해야 할 것은 RS-232 표준은 각 직렬 데이터 워드의 끝에 적어도 하나의 데이터 비트 사이클이 논리적인 "1"로 유지될 것"\(즉, 시작 비트, 데이터 비트, 패리티 비트, 정지 비트로부터의 완전한 문자\)이라고만 명시하고 있다는 점이다. 두 컴퓨터 사이에 타이밍 문제가 있지만 일반적으로 한 번에 하나씩 문자를 보낼 수 있다면 보드 속도를 줄이는 대신 두 번째 정지 비트를 추가해야 할 수도 있다. 이는 \(일반적으로\) 보 레이트를 떨어뜨려 전송 속도를 절반으로 줄이는 대신 문자당 전송 속도에 1비트 페널티를 더한다.

비트 3, 4, 5는 각 직렬 워드가 패리티 정보에 반응하는 방법을 제어한다. 비트 3이 논리 "0"인 경우, 이는 패리티 비트가 직렬 데이터 워드와 함께 전송되지 않도록 한다. 대신에 그것은 즉시 정지 비트로 옮겨가고, 이 수준에서 패리티를 확인하는 것은 정말 쓸모없는 것이라는 것을 인정하는 것이다. 당신은 여전히 패리티 비트를 포함시킴으로써 데이터 전송으로 약간의 신뢰성을 얻을 수 있지만, 이 책의 다른 장에서 논의될 더 신뢰할 수 있고 실용적인 방법들이 있다. 패리티 검사를 포함하려면 "없음" 패리티 이외의 각 패리티 방법을 설명하십시오.

오드 패리티 직렬 워드의 데이터 부분의 각 비트는 논리 "1" 비트 수의 단순한 카운트로 추가된다. 만약 이것이 홀수 비트 수라면, 패리티 비트는 논리적인 "0"으로 전송될 것이다. 카운트가 짝수일 경우 패리티 비트는 논리 "1"로 전송되어 "1" 비트의 수를 홀수화한다. 짝수 패리티 오드 패리티처럼 비트가 함께 추가된다. 그러나 이 경우 비트 수가 홀수 숫자로 끝나게 되면 "1" 비트 수가 균등해지도록 논리적인 "1"로 전송되는데 이는 홀수 패리티와 정반대다. 마크 패리티 이 경우 패리티 비트는 항상 논리 "1"이 된다. 이것은 약간 이상해 보일 수 있지만, 이것은 시험과 진단 목적으로 사용된다. 직렬 연결의 수신 끝에 있는 소프트웨어가 패리티 오류에 정확하게 반응하고 있는지 확인하려면, 마크나 스페이스 패리티를 보내고, 수신 UART나 장치가 패리티에 대해 기대하는 것을 충족하지 못하는 문자를 보낼 수 있다. Mark Parity의 경우에만 이 비트를 추가 "Stop 비트"로 사용할 수 있다. RS-232 표준은 직렬 데이터 워드를 끝내기 위한 논리 "1"을 예상하고 있으므로 수신 컴퓨터는 "마크" 패리티 비트와 정지 비트 사이의 차이를 구별할 수 없다는 것을 기억한다. 본질적으로, 당신은 이 설정을 사용하고 또한 이 레지스터의 정지 비트 부분을 적절하게 사용함으로써 3 또는 2.5의 정지 비트를 가질 수 있다. 이는 일반적인 응용 프로그램이 허용하지 않는 방식으로 컴퓨터의 설정을 "취약"하거나 최소한 직렬 데이터 설정에 대한 보다 깊은 통찰력을 얻을 수 있는 방법이다. 스페이스 패리티 마크 패리티와 마찬가지로, 이것은 패리티 비트를 "sticky"로 만들어, 변하지 않는다. 이 경우 문자를 전송할 때마다 패리티 비트에 대해 논리 "0"을 입력한다. 각 일련 단어에 대해 9개의 데이터 비트를 삽입하는 조잡한 방법 또는 위에서 설명한 진단 목적 이외의 실질적인 용도는 많지 않다. 비트 6을 1로 설정하면 TX 와이어가 논리적으로 "0"이 되어 그대로 유지되며, 수신 UART - "브레이크 상태"에 의해 "0" 비트의 긴 스트림으로 해석된다. "break"를 끝내려면 비트 6을 다시 0으로 설정하십시오.

모뎀 제어 레지스터 

오프셋: +4 . 이 레지스터를 사용하면 소프트웨어 제어 하에 "하드웨어" 플로우 제어를 할 수 있다. 또는 보다 실용적인 방법으로 UART의 4개의 다른 와이어를 직접 조작할 수 있으며, 어떤 일련의 독립적인 논리적 상태로 설정할 수 있으며, 모뎀의 제어를 제공할 수 있다. 또한 대부분의 UART에는 인터럽트를 활성화하려면 논리적 "1"로 설정된 보조 출력 2가 필요하다는 점에 유의해야 한다.



**Modem Control Register \(MCR\)**

| Bit | Notes |
| :--- | :--- |


| 7 | Reserved |
| :--- | :--- |


| 6 | Reserved |
| :--- | :--- |


| 5 | Autoflow Control Enabled \(16750\) |
| :--- | :--- |


| 4 | Loopback Mode |
| :--- | :--- |


| 3 | Auxiliary Output 2 |
| :--- | :--- |


| 2 | Auxiliary Output 1 |
| :--- | :--- |


| 1 | Request To Send |
| :--- | :--- |


| 0 | Data Terminal Ready |
| :--- | :--- |


일반적인 PC 플랫폼에 있는 이러한 출력 중 실제로 DB-9 커넥터의 PC 출력에 연결된 것은 송신 요청\(RTS\)과 데이터 터미널 준비\(DTR\)뿐이다. DB-25 시리얼 커넥터\(PC 플랫폼에서 병렬 통신에 더 일반적으로 사용됨\)가 있거나 확장 카드에 사용자 정의 UART가 있는 경우 보조 출력이 RS-232 연결에 연결될 수 있다. 사용자 지정 회로에서 이 칩을 구성 요소로 사용하는 경우, 이것은 칩 설계에서 TTL 출력에 의해 트리거되고 싶은 모든 것을 표시하기 위해 사용할 수 있는 몇 가지 "무료" 추가 출력 신호를 제공하며, 소프트웨어 제어 하에 있을 수 있다. 이것을 하는 더 쉬운 방법들이 있지만, 이 경우 그것은 당신의 레이아웃에 추가 칩을 절약할 수 있을 것이다.

"루프백" 모드는 주로 UART를 테스트하여 주 CPU와 UART 사이에서 회로가 작동하는지 확인하는 방법이다. 이것은, 비록, 최종 사용자가 시험할 필요는 거의 없지만, UART를 사용하는 일부 소프트웨어의 초기 시험에는 유용할 수 있다. 이것이 "1"의 논리적 상태로 설정되면 송신 레지스터에 입력되는 모든 문자는 UART의 수신 레지스터에서 즉시 발견된다. 위에 나열된 RTS와 DTS와 같은 다른 논리적 신호는 직렬 통신 포트 끝에 루프백 RS-232 장치를 놓은 것처럼 모뎀 상태 레지스터에 나타난다. 요컨대, 이것은 당신이 소프트웨어만을 사용하여 루프백 테스트를 할 수 있게 해준다. 이러한 진단 목적과 UART를 사용하는 소프트웨어의 일부 초기 개발 테스트를 제외하고, 이 테스트는 결코 사용되지 않을 것이다.

16750에는 모뎀 제어 레지스터를 사용하여 호출할 수 있는 특수 모드가 있다. 기본적으로 이것은 UART가 FIFO의 현재 상태에 따라 하드웨어 문자 흐름 제어를 위해 RTS와 DTS의 상태를 직접 제어할 수 있게 한다. 이 동작은 FIFO Control Register\(FCR\)의 비트 5 상태에도 영향을 받는다. 이것이 유용하고 UART 제어 소프트웨어를 작성하는 방법에 대한 논리의 일부를 바꿀 수 있지만, 16750은 칩으로서 비교적 새롭고 많은 컴퓨터 시스템에서 흔히 찾아볼 수 없다. 컴퓨터에 16750 UART가 있다는 것을 알고 있다면, 이 향상된 기능을 활용해 보십시오.

### 라인 상태 레지스터 

오프셋: +5 . 이 레지스터는 수신된 데이터를 기반으로 UART 내에 존재할 수 있는 오류 상태에 대한 정보를 제공하는 데 주로 사용된다. 이 레지스터는 "읽기 전용" 레지스터이며, 이 레지스터에 기록된 데이터는 무시되거나 더 나빠질 가능성이 있으며, UART에서 다른 행동을 유발한다는 점을 유념하십시오. 이 정보에는 여러 가지 용도가 있으며, 직렬 데이터 연결 문제를 진단하는 데 유용할 수 있는 몇 가지 정보가 아래에 제공될 것이다.



**Line Status Register \(LSR\)**

| Bit | Notes |
| :--- | :--- |


| 7 | Error in Received FIFO |
| :--- | :--- |


| 6 | Empty Data Holding Registers |
| :--- | :--- |


| 5 | Empty Transmitter Holding Register |
| :--- | :--- |


| 4 | Break Interrupt |
| :--- | :--- |


| 3 | Framing Error |
| :--- | :--- |


| 2 | Parity Error |
| :--- | :--- |


| 1 | Overrun Error |
| :--- | :--- |


| 0 | Data Ready |
| :--- | :--- |


비트 7은 FIFO에 문자가 있는 오류를 가리킨다. 만약 현재 FIFO에 있는 어떤 캐릭터가 여기에 나열된 다른 오류 메시지\(프레임 오류, 패리티 오류 등\)를 가지고 있다면, 이것은 FIFO의 문자 데이터가 신뢰할 수 없고 하나 이상의 오류를 가지고 있기 때문에 FIFO를 지울 필요가 있음을 상기시키는 것이다. FIFO가 없는 UART 칩에서는 예약 비트 필드 입니다.

비트 5와 6은 문자 송신기 회로의 상태를 말하며 UART가 다른 문자를 수신할 준비가 되었는지 확인하는 데 도움이 될 수 있다. 비트 6은 모든 문자를 전송\(FIFO 포함, 활성화된 경우\)하고 "시프트 레지스터"도 전송하는 경우 논리 "1"로 설정된다. 이 시프트 레지스터는 송신기 홀딩 버퍼\(THB\)나 FIFO로부터 데이터를 수집하는 UART 내의 내부 메모리 블록으로, 데이터를 직렬 형식으로 실제 변환하여 한 번에 1비트의 데이터를 전송하고 시프트 레지스터의 내용을 1비트 아래로 "전환"하여 t의 값을 얻는 회로다.그 다음에. 비트 5는 단지 전송을 위한 FIFO를 포함하여 UART가 더 많은 문자를 수신할 수 있다는 것을 말해준다.

Break Interrupt \(비트 4\)는 연속 데이터 입력 라인이 "0" 비트를 최소한 전체 직렬 데이터 "word"만큼 긴 시간 동안 Divisor Latch Bytes의 지정된 보레이트에 대해 "0" 비트를 수신했을 때 논리적으로 "1"에 도달한다. \(직렬 라인의 정상 상태는 se에 해당함\)nd "1" 비트 또는 항상 "0" 비트인 시작 비트를 보낸 다음 가변 데이터 및 패리티 비트를 보낸 다음 "1"인 정지 비트는 라인이 유휴 상태일 경우 더 "1"s로 계속 진행됨.\) 보통 정상 상태 대신 "0" 비트의 긴 시퀀스는 컴퓨터에 직렬 데이터를 전송하는 장치가 어떤 이유로 중지되었음을 의미한다. 종종 직렬 통신의 경우 이것은 정상적인 상태지만, 이런 방식으로 다른 장치가 어떻게 작동하는지 모니터링할 수 있는 방법이 있다. 일부 직렬 단자는 Out-of-Band 신호 방식으로서 이 "Break 조건"을 생성하게 하는 키를 가지고 있다.

프레임 오류\(비트 3\)는 마지막 비트가 정지 비트가 아닐 때 발생한다. 또는 좀 더 정확히 말하면 정지 비트는 논리적인 "0"이다. 여기에는 몇 가지 원인이 있는데, 여기에는 두 컴퓨터가 일치하지 않는 타이밍이 있다. 이는 기기 간 물리적 케이블의 문제 또는 케이블이 너무 길다는 등의 다른 원인들도 수반될 수 있지만, 일반적으로 보레이트 불일치로 인해 발생한다. 데이터 비트의 개수도 꺼질 수 있으므로 이와 같은 오류가 발생했을 때 UART\(데이터 비트 길이, 패리티 및 중지 비트 수\)에 대한 모든 설정이 예상되어야 하는 것인지 확인하기 위해 직렬 데이터 프로토콜을 매우 면밀하게 확인하십시오.

패리티 오류\(비트 2\)는 프레임 오류와 같이 일치하지 않는 보레이트를 나타낼 수도 있다\(특히 두 오류가 동시에 발생하는 경우\). 이 비트는 예상되는 패리티 알고리즘\(오드, 짝수, 마크 또는 공백\)이 발견되지 않았을 때 발생한다. UART 설정에서 "No parity"를 사용하는 경우, 이 비트는 항상 논리적인 "0"이어야 한다. 프레임 오류가 발생하지 않을 때, 이것은 케이블에 문제가 있다는 것을 확인하는 방법이다. 다른 문제들도 처리할 수 있다.

오버런 오류\(비트 1\)는 UART에 제대로 접근하지 못하는 프로그래밍 불량 또는 운영 체제의 표시다. 이 오류 상태는 판독 대기 중인 문자가 있고 들어오는 변속 레지스터가 다음 문자의 내용을 수신기 버퍼\(RBR\)로 이동하려고 할 때 발생한다. FIFO가 장착된 UART의 경우 FIFO도 가득 찼음을 나타낸다.

UART에 액세스하는 소프트웨어가 얼마나 효율적인지, 특히 들어오는 데이터를 모니터링하고 읽는 부분을 포함하여 이러한 오류를 제거하는 데 도움이 되는 몇 가지 작업을 하십시오. 멀티태스킹 운영 체제에서는 수신 데이터를 읽는 소프트웨어 부분이 별도의 스레드에 있는지, 스레드 우선 순위가 높거나 시간이 중요한지 확인하고 싶을 수 있는데, 이는 직렬 통신 데이터를 사용하는 소프트웨어에서 매우 중요한 작업이기 때문이다. 또한 애플리케이션을 위한 좋은 소프트웨어 관행에는 소프트웨어를 통해 수행되는 애플리케이션별 "버퍼"를 추가하여, 필요에 따라 들어오는 데이터를 처리할 수 있는 더 많은 기회를 제공하고, UART에서 데이터를 빼내는 데 필요한 중요한 서브루틴에서 벗어나게 해준다. 이 버퍼는 1KB에서 최대 1MB까지 작을 수 있으며 작업 중인 데이터의 종류에 따라 크게 달라진다. 응용 프로그램 개발 영역에도 적용되며, 이후 모듈에서도 적용될 수 있는 좀 더 이국적인 버퍼링 기법이 있다.

### 모뎀 상태 레지스터 

오프셋: +6 . 이 레지스터는 모뎀의 현재 상태를 소프트웨어에 알리기 위해 여기에 있는 또 다른 읽기 전용 레지스터 입니다. 이러한 방식으로 액세스하는 모뎀은 외부 모뎀이거나 UART를 컴퓨터에 대한 인터페이스로 사용하는 내부 모뎀일 수 있다.

**Modem Status Register \(MSR\)**

| Bit | Notes |
| :--- | :--- |


| 7 | Carrier Detect |
| :--- | :--- |


| 6 | Ring Indicator |
| :--- | :--- |


| 5 | Data Set Ready |
| :--- | :--- |


| 4 | Clear To Send |
| :--- | :--- |


| 3 | Delta Data Carrier Detect |
| :--- | :--- |


| 2 | Trailing Edge Ring Indicator |
| :--- | :--- |


| 1 | Delta Data Set Ready |
| :--- | :--- |


| 0 | Delta Clear To Send |
| :--- | :--- |


비트 7과 6은 모뎀 활동과 직접 관련이 있다. 반송파 탐지기는 모뎀이 다른 모뎀에 "연결"되어 있는 동안 "1"의 논리적 상태를 유지할 것이다. 이것이 "0"이라는 논리적인 상태로 갈 때, 당신은 전화 연결이 끊겼다고 가정할 수 있다. 링 표시기 비트는 "RI" 또는 링 표시기라고도 하는 RS-232 와이어에 직접 연결된다. 보통 이 비트는 전화선의 "링 전압"이 감지된 결과 "1"의 논리적 상태로 전환되는데, 마치 누군가가 당신에게 전화를 걸려고 한다는 것을 알려주기 위해 재래식 전화가 울릴 때와 같다.

AT 모뎀 명령의 섹션에 도달하면 모뎀의 상태에 관한 이 정보 및 기타 정보를 알려주는 다른 방법이 있을 것이며, 대신 이 정보는 특수 와이어 대신 일반적인 직렬 데이터 스트림의 문자로 보내질 것이다. 사실, 이러한 여분의 비트는 상당히 가치가 없지만, 처음부터 규격의 일부였으며 UART 설계자들은 비교적 쉽게 구현할 수 있다. 그러나, 그것은 일부 추가 정보를 효율적으로 전송하거나 UART를 사용하는 소프트웨어 설계자가 다른 목적을 위해 다른 장치로부터 논리 비트 신호를 수신하도록 허용하는 방법이 될 수 있다.

"Data Set Ready"와 "Clear To Send" 비트\(비트 4, 5\)는 RS-232 케이블에서 직접 발견되며, "Modem Control Register \(MCR\)로 전송되는 "Receest To Derminal Ready"와 와이어를 일치시키고 있다. 2개의 레지스터에 이 4개의 비트를 사용하면 "하드웨어 플로우 제어"를 수행할 수 있으며, 이 경우 다른 장치에 더 많은 데이터를 보낼 때라고 신호를 보내거나 정보를 처리하는 동안 데이터 전송을 보류하고 중지할 수 있다. 데이터 흐름 제어에 도달하면 다른 모듈에서 이 주제에 대한 자세한 내용이 기록될 것이다.

"델타" 비트\(비트 0, 1, 2, 3\)에 대한 참고 사항. 이 경우 "델타"라는 단어는 비트 중 하나의 상태 변화에서와 같이 변화를 의미한다. 이것은 델타베가 속도의 변화를 의미하는 로켓 과학과 같은 다른 과학 분야로부터 온다. 이 레지스터의 목적상, 다음에 이 모뎀 상태 레지스터에 접근할 때\(예: 캐리어 디텍트를 사용한 델타 데이터 캐리어 디텍트\)와 관련된 비트가 이전 레지스터에 액세스했을 때와 논리적 상태가 변경된 경우 이러한 비트는 각각 논리 "1"이 된다. "링 표시기" 비트가 논리 "1"에서 논리 "0" 상태로 바뀐 경우에만 논리 "1" 상태에 있다는 점을 제외하면, 추적 에지 링 표시기는 나머지 것과 거의 비슷하다. 이 지식에는 실제로 실제적인 용도는 별로 없지만, 이러한 비트를 이용하여 UART로부터 수신한 데이터를 이 비트에 근거하여 어느 정도 조작하려고 하는 소프트웨어가 있다. 만약 당신이 이 4비트를 무시한다면 당신은 여전히 매우 강력한 직렬 통신 소프트웨어를 만들 수 있다.

### 스크래치 레지스터 

오프셋: +7 . Scratch 레지스터는 흥미로운 수수께끼다. 설계자들이 무엇을 해야 할지 모르는 추가 "등록"을 가진 다른 모든 I/O 포트 주소로 레지스터 전체를 압축하기 위해 많은 노력을 기울였다. 컴퓨터 아키텍처를 다룰 때는 2의 힘을 다룰 때 더 쉬웠기 때문에 8개의 I/O 포트를 "접근"해야 한다는 것을 명심하라. 다른 기기가 이 추가 I/O 포트를 사용하도록 허용하면 마더보드 설계가 너무 복잡해질 수 있다.

8250 UART의 일부 변형에서는 이 스크래치 레지스터에 기록된 모든 데이터를 이 레지스터의 I/O 포트를 읽을 때 소프트웨어에서 사용할 수 있다. 사실상, 이것은 여러분이 유용하다고 생각하는 어떤 방식으로든 여러분의 어플리케이션에서 사용할 수 있는 "메모리"를 한 바이트 더 준다. 바이러스 작성자 외에 \(아무런 아이디어라도 내서는 안 될 것 같다\) 이 레지스터에는 실제로 좋은 용도가 없다. 원래 8250은 이 레지스터를 통해 전송된 데이터를 저장하지 않았기 때문에 이 레지스터를 사용하여 UART의 특정 변형을 식별할 수 있다는 점이 제한적이다. 그 칩은 PC 디자인에 더 이상 사용되지 않기 때문에 \(그 회사들은 16550과 같이 더 진보된 칩을 사용하고 있다\), 당신은 대부분의 최신 PC 타입 플랫폼에서 그 "버그"를 찾을 수 없을 것이다. 아래에 사용자 컴퓨터에서 사용 중인 UART 칩을 소프트웨어로 식별하는 방법과 각 직렬 포트에 대한 자세한 정보가 제공될 것이다.

### UART의 소프트웨어 식별 

소프트웨어 루틴만으로 컴퓨터 시스템의 많은 구성요소를 식별할 수 있는 것처럼, 컴퓨터에서도 발견된 UART의 어떤 버전이나 변형을 감지할 수 있다. 이것이 가능한 이유는 UART 칩의 각 버전마다 몇 가지 고유한 특성이 있기 때문에 제거 과정을 거치면 어떤 버전을 다루고 있는지 확인할 수 있기 때문이다. 이는 직렬 I/O 루틴의 성능을 향상시키고, 정보를 전송하고 전송하는 데 사용할 수 있는 버퍼가 있는지 알고, PC의 장비를 더 잘 알고자 하는 경우에 유용한 정보가 될 수 있다.

UART 버전을 결정하는 방법의 한 예는 Scratch Register가 작동하는지 여부다. 처음 8250과 8250A 칩에는 스크래치 레지스터가 작동하지 않는 칩 모델의 설계에 결함이 있었다. 만약 당신이 이 레지스터에 약간의 데이터를 썼다가 그것이 다시 바뀐다면, 당신은 당신의 컴퓨터에 있는 UART가 이 두 개의 칩 모델 중 하나라는 것을 알 것이다.

FIFO 제어 레지스터가 있는 곳이 또 있다. 이 레지스터의 비트 "0"을 논리 1로 설정하면, 이 칩의 최신 버전에서만 볼 수 있는 UART의 FIFO를 활성화하려고 하는 것이다. 비트 "6"과 "7"을 읽으면 16550 또는 16550A 칩 중 하나를 사용하는지 결정하는 데 도움이 될 것이다. 비트 "5"는 칩이 16750인지 여부를 결정하는 데 도움이 될 것이다.

다음은 사용 중인 칩의 종류를 결정하는 데 도움이 되는 전체 의사 코드 알고리즘이다.

```text
Set the value "0xE7" to the FCR to test the status of the FIFO flags.
Read the value of the IIR to test for what flags actually got set.
If Bit 6 is set Then
  If Bit 7 is set Then
    If Bit 5 is set Then
      UART is 16750
    Else
      UART is 16550A
    End If
  Else
    UART is 16550
  End If
Else you know the chip doesn't use FIFO, so we need to check the scratch register
  Set some arbitrary value like 0x2A to the Scratch Register.  
  You don't want to use 0xFF or 0x00 as those might be returned by the Scratch Register instead for a false postive result.
  Read the value of the Scratch Register
  If the arbitrary value comes back identical
    UART is 16450
  Else
    UART is 8250
  End If
End If
```

